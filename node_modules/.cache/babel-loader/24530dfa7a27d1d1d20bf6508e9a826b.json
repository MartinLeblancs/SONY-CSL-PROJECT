{"ast":null,"code":"var Sprite = require('../sprites/Sprite'),\n    Texture = require('../textures/Texture'),\n    math = require('../math'),\n    utils = require('../utils'),\n    CONST = require('../const');\n/**\n * A Text Object will create a line or multiple lines of text. To split a line you can use '\\n' in your text string,\n * or add a wordWrap property set to true and and wordWrapWidth property with a value in the style object.\n *\n * A Text can be created directly from a string and a style object\n *\n * ```js\n * var text = new PIXI.Text('This is a pixi text',{font : '24px Arial', fill : 0xff1010, align : 'center'});\n * ```\n *\n * @class\n * @extends PIXI.Sprite\n * @memberof PIXI\n * @param text {string} The copy that you would like the text to display\n * @param [style] {object} The style parameters\n * @param [style.font] {string} default 'bold 20px Arial' The style and size of the font\n * @param [style.fill='black'] {String|Number} A canvas fillstyle that will be used on the text e.g 'red', '#00FF00'\n * @param [style.align='left'] {string} Alignment for multiline text ('left', 'center' or 'right'), does not affect single line text\n * @param [style.stroke] {String|Number} A canvas fillstyle that will be used on the text stroke e.g 'blue', '#FCFF00'\n * @param [style.strokeThickness=0] {number} A number that represents the thickness of the stroke. Default is 0 (no stroke)\n * @param [style.wordWrap=false] {boolean} Indicates if word wrap should be used\n * @param [style.wordWrapWidth=100] {number} The width at which text will wrap, it needs wordWrap to be set to true\n * @param [style.lineHeight] {number} The line height, a number that represents the vertical space that a letter uses\n * @param [style.dropShadow=false] {boolean} Set a drop shadow for the text\n * @param [style.dropShadowColor='#000000'] {string} A fill style to be used on the dropshadow e.g 'red', '#00FF00'\n * @param [style.dropShadowAngle=Math.PI/4] {number} Set a angle of the drop shadow\n * @param [style.dropShadowDistance=5] {number} Set a distance of the drop shadow\n * @param [style.padding=0] {number} Occasionally some fonts are cropped on top or bottom. Adding some padding will\n *      prevent this from happening by adding padding to the top and bottom of text height.\n * @param [style.textBaseline='alphabetic'] {string} The baseline of the text that is rendered.\n * @param [style.lineJoin='miter'] {string} The lineJoin property sets the type of corner created, it can resolve\n *      spiked text issues. Default is 'miter' (creates a sharp corner).\n * @param [style.miterLimit=10] {number} The miter limit to use when using the 'miter' lineJoin mode. This can reduce\n *      or increase the spikiness of rendered text.\n */\n\n\nfunction Text(text, style, resolution) {\n  /**\n   * The canvas element that everything is drawn to\n   *\n   * @member {HTMLCanvasElement}\n   */\n  this.canvas = document.createElement('canvas');\n  /**\n   * The canvas 2d context that everything is drawn with\n   * @member {HTMLCanvasElement}\n   */\n\n  this.context = this.canvas.getContext('2d');\n  /**\n   * The resolution of the canvas.\n   * @member {number}\n   */\n\n  this.resolution = resolution || CONST.RESOLUTION;\n  /**\n   * Private tracker for the current text.\n   *\n   * @member {string}\n   * @private\n   */\n\n  this._text = null;\n  /**\n   * Private tracker for the current style.\n   *\n   * @member {object}\n   * @private\n   */\n\n  this._style = null;\n  var texture = Texture.fromCanvas(this.canvas);\n  texture.trim = new math.Rectangle();\n  Sprite.call(this, texture);\n  this.text = text;\n  this.style = style;\n} // constructor\n\n\nText.prototype = Object.create(Sprite.prototype);\nText.prototype.constructor = Text;\nmodule.exports = Text;\nText.fontPropertiesCache = {};\nText.fontPropertiesCanvas = document.createElement('canvas');\nText.fontPropertiesContext = Text.fontPropertiesCanvas.getContext('2d');\nObject.defineProperties(Text.prototype, {\n  /**\n   * The width of the Text, setting this will actually modify the scale to achieve the value set\n   *\n   * @member {number}\n   * @memberof Text#\n   */\n  width: {\n    get: function get() {\n      if (this.dirty) {\n        this.updateText();\n      }\n\n      return this.scale.x * this._texture._frame.width;\n    },\n    set: function set(value) {\n      this.scale.x = value / this._texture._frame.width;\n      this._width = value;\n    }\n  },\n\n  /**\n   * The height of the Text, setting this will actually modify the scale to achieve the value set\n   *\n   * @member {number}\n   * @memberof Text#\n   */\n  height: {\n    get: function get() {\n      if (this.dirty) {\n        this.updateText();\n      }\n\n      return this.scale.y * this._texture._frame.height;\n    },\n    set: function set(value) {\n      this.scale.y = value / this._texture._frame.height;\n      this._height = value;\n    }\n  },\n\n  /**\n   * Set the style of the text\n   *\n   * @param [style] {object} The style parameters\n   * @param [style.font='bold 20pt Arial'] {string} The style and size of the font\n   * @param [style.fill='black'] {string|number} A canvas fillstyle that will be used on the text eg 'red', '#00FF00'\n   * @param [style.align='left'] {string} Alignment for multiline text ('left', 'center' or 'right'), does not affect single line text\n   * @param [style.stroke='black'] {string|number} A canvas fillstyle that will be used on the text stroke eg 'blue', '#FCFF00'\n   * @param [style.strokeThickness=0] {number} A number that represents the thickness of the stroke. Default is 0 (no stroke)\n   * @param [style.wordWrap=false] {boolean} Indicates if word wrap should be used\n   * @param [style.wordWrapWidth=100] {number} The width at which text will wrap\n   * @param [style.lineHeight] {number} The line height, a number that represents the vertical space that a letter uses\n   * @param [style.dropShadow=false] {boolean} Set a drop shadow for the text\n   * @param [style.dropShadowColor='#000000'] {string|number} A fill style to be used on the dropshadow e.g 'red', '#00FF00'\n   * @param [style.dropShadowAngle=Math.PI/6] {number} Set a angle of the drop shadow\n   * @param [style.dropShadowDistance=5] {number} Set a distance of the drop shadow\n   * @param [style.padding=0] {number} Occasionally some fonts are cropped on top or bottom. Adding some padding will\n   *      prevent this from happening by adding padding to the top and bottom of text height.\n   * @param [style.textBaseline='alphabetic'] {string} The baseline of the text that is rendered.\n   * @param [style.lineJoin='miter'] {string} The lineJoin property sets the type of corner created, it can resolve\n   *      spiked text issues. Default is 'miter' (creates a sharp corner).\n   * @param [style.miterLimit=10] {number} The miter limit to use when using the 'miter' lineJoin mode. This can reduce\n   *      or increase the spikiness of rendered text.\n   * @memberof Text#\n   */\n  style: {\n    get: function get() {\n      return this._style;\n    },\n    set: function set(style) {\n      style = style || {};\n\n      if (typeof style.fill === 'number') {\n        style.fill = utils.hex2string(style.fill);\n      }\n\n      if (typeof style.stroke === 'number') {\n        style.stroke = utils.hex2string(style.stroke);\n      }\n\n      if (typeof style.dropShadowColor === 'number') {\n        style.dropShadowColor = utils.hex2string(style.dropShadowColor);\n      }\n\n      style.font = style.font || 'bold 20pt Arial';\n      style.fill = style.fill || 'black';\n      style.align = style.align || 'left';\n      style.stroke = style.stroke || 'black'; //provide a default, see: https://github.com/GoodBoyDigital/pixi.js/issues/136\n\n      style.strokeThickness = style.strokeThickness || 0;\n      style.wordWrap = style.wordWrap || false;\n      style.wordWrapWidth = style.wordWrapWidth || 100;\n      style.dropShadow = style.dropShadow || false;\n      style.dropShadowColor = style.dropShadowColor || '#000000';\n      style.dropShadowAngle = style.dropShadowAngle || Math.PI / 6;\n      style.dropShadowDistance = style.dropShadowDistance || 5;\n      style.padding = style.padding || 0;\n      style.textBaseline = style.textBaseline || 'alphabetic';\n      style.lineJoin = style.lineJoin || 'miter';\n      style.miterLimit = style.miterLimit || 10;\n      this._style = style;\n      this.dirty = true;\n    }\n  },\n\n  /**\n   * Set the copy for the text object. To split a line you can use '\\n'.\n   *\n   * @param text {string} The copy that you would like the text to display\n   * @memberof Text#\n   */\n  text: {\n    get: function get() {\n      return this._text;\n    },\n    set: function set(text) {\n      text = text.toString() || ' ';\n\n      if (this._text === text) {\n        return;\n      }\n\n      this._text = text;\n      this.dirty = true;\n    }\n  }\n});\n/**\n * Renders text and updates it when needed\n *\n * @private\n */\n\nText.prototype.updateText = function () {\n  var style = this._style;\n  this.context.font = style.font; // word wrap\n  // preserve original text\n\n  var outputText = style.wordWrap ? this.wordWrap(this._text) : this._text; // split text into lines\n\n  var lines = outputText.split(/(?:\\r\\n|\\r|\\n)/); // calculate text width\n\n  var lineWidths = new Array(lines.length);\n  var maxLineWidth = 0;\n  var fontProperties = this.determineFontProperties(style.font);\n\n  for (var i = 0; i < lines.length; i++) {\n    var lineWidth = this.context.measureText(lines[i]).width;\n    lineWidths[i] = lineWidth;\n    maxLineWidth = Math.max(maxLineWidth, lineWidth);\n  }\n\n  var width = maxLineWidth + style.strokeThickness;\n\n  if (style.dropShadow) {\n    width += style.dropShadowDistance;\n  }\n\n  this.canvas.width = (width + this.context.lineWidth) * this.resolution; // calculate text height\n\n  var lineHeight = this.style.lineHeight || fontProperties.fontSize + style.strokeThickness;\n  var height = lineHeight * lines.length;\n\n  if (style.dropShadow) {\n    height += style.dropShadowDistance;\n  }\n\n  this.canvas.height = (height + this._style.padding * 2) * this.resolution;\n  this.context.scale(this.resolution, this.resolution);\n\n  if (navigator.isCocoonJS) {\n    this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);\n  } //this.context.fillStyle=\"#FF0000\";\n  //this.context.fillRect(0, 0, this.canvas.width, this.canvas.height);\n\n\n  this.context.font = style.font;\n  this.context.strokeStyle = style.stroke;\n  this.context.lineWidth = style.strokeThickness;\n  this.context.textBaseline = style.textBaseline;\n  this.context.lineJoin = style.lineJoin;\n  this.context.miterLimit = style.miterLimit;\n  var linePositionX;\n  var linePositionY;\n\n  if (style.dropShadow) {\n    this.context.fillStyle = style.dropShadowColor;\n    var xShadowOffset = Math.cos(style.dropShadowAngle) * style.dropShadowDistance;\n    var yShadowOffset = Math.sin(style.dropShadowAngle) * style.dropShadowDistance;\n\n    for (i = 0; i < lines.length; i++) {\n      linePositionX = style.strokeThickness / 2;\n      linePositionY = style.strokeThickness / 2 + i * lineHeight + fontProperties.ascent;\n\n      if (style.align === 'right') {\n        linePositionX += maxLineWidth - lineWidths[i];\n      } else if (style.align === 'center') {\n        linePositionX += (maxLineWidth - lineWidths[i]) / 2;\n      }\n\n      if (style.fill) {\n        this.context.fillText(lines[i], linePositionX + xShadowOffset, linePositionY + yShadowOffset + this._style.padding);\n      }\n    }\n  } //set canvas text styles\n\n\n  this.context.fillStyle = style.fill; //draw lines line by line\n\n  for (i = 0; i < lines.length; i++) {\n    linePositionX = style.strokeThickness / 2;\n    linePositionY = style.strokeThickness / 2 + i * lineHeight + fontProperties.ascent;\n\n    if (style.align === 'right') {\n      linePositionX += maxLineWidth - lineWidths[i];\n    } else if (style.align === 'center') {\n      linePositionX += (maxLineWidth - lineWidths[i]) / 2;\n    }\n\n    if (style.stroke && style.strokeThickness) {\n      this.context.strokeText(lines[i], linePositionX, linePositionY + this._style.padding);\n    }\n\n    if (style.fill) {\n      this.context.fillText(lines[i], linePositionX, linePositionY + this._style.padding);\n    }\n  }\n\n  this.updateTexture();\n};\n/**\n * Updates texture size based on canvas size\n *\n * @private\n */\n\n\nText.prototype.updateTexture = function () {\n  var texture = this._texture;\n  texture.baseTexture.hasLoaded = true;\n  texture.baseTexture.resolution = this.resolution;\n  texture.baseTexture.width = this.canvas.width / this.resolution;\n  texture.baseTexture.height = this.canvas.height / this.resolution;\n  texture.crop.width = texture._frame.width = this.canvas.width / this.resolution;\n  texture.crop.height = texture._frame.height = this.canvas.height / this.resolution;\n  texture.trim.x = 0;\n  texture.trim.y = -this._style.padding;\n  texture.trim.width = texture._frame.width;\n  texture.trim.height = texture._frame.height - this._style.padding * 2;\n  this._width = this.canvas.width / this.resolution;\n  this._height = this.canvas.height / this.resolution;\n  texture.baseTexture.emit('update', texture.baseTexture);\n  this.dirty = false;\n};\n/**\n * Renders the object using the WebGL renderer\n *\n * @param renderer {WebGLRenderer}\n */\n\n\nText.prototype.renderWebGL = function (renderer) {\n  if (this.dirty) {\n    //this.resolution = 1//renderer.resolution;\n    this.updateText();\n  }\n\n  Sprite.prototype.renderWebGL.call(this, renderer);\n};\n/**\n * Renders the object using the Canvas renderer\n *\n * @param renderer {CanvasRenderer}\n * @private\n */\n\n\nText.prototype._renderCanvas = function (renderer) {\n  if (this.dirty) {\n    //   this.resolution = 1//renderer.resolution;\n    this.updateText();\n  }\n\n  Sprite.prototype._renderCanvas.call(this, renderer);\n};\n/**\n * Calculates the ascent, descent and fontSize of a given fontStyle\n *\n * @param fontStyle {object}\n * @private\n */\n\n\nText.prototype.determineFontProperties = function (fontStyle) {\n  var properties = Text.fontPropertiesCache[fontStyle];\n\n  if (!properties) {\n    properties = {};\n    var canvas = Text.fontPropertiesCanvas;\n    var context = Text.fontPropertiesContext;\n    context.font = fontStyle;\n    var width = Math.ceil(context.measureText('|MÉq').width);\n    var baseline = Math.ceil(context.measureText('M').width);\n    var height = 2 * baseline;\n    baseline = baseline * 1.4 | 0;\n    canvas.width = width;\n    canvas.height = height;\n    context.fillStyle = '#f00';\n    context.fillRect(0, 0, width, height);\n    context.font = fontStyle;\n    context.textBaseline = 'alphabetic';\n    context.fillStyle = '#000';\n    context.fillText('|MÉq', 0, baseline);\n    var imagedata = context.getImageData(0, 0, width, height).data;\n    var pixels = imagedata.length;\n    var line = width * 4;\n    var i, j;\n    var idx = 0;\n    var stop = false; // ascent. scan from top to bottom until we find a non red pixel\n\n    for (i = 0; i < baseline; i++) {\n      for (j = 0; j < line; j += 4) {\n        if (imagedata[idx + j] !== 255) {\n          stop = true;\n          break;\n        }\n      }\n\n      if (!stop) {\n        idx += line;\n      } else {\n        break;\n      }\n    }\n\n    properties.ascent = baseline - i;\n    idx = pixels - line;\n    stop = false; // descent. scan from bottom to top until we find a non red pixel\n\n    for (i = height; i > baseline; i--) {\n      for (j = 0; j < line; j += 4) {\n        if (imagedata[idx + j] !== 255) {\n          stop = true;\n          break;\n        }\n      }\n\n      if (!stop) {\n        idx -= line;\n      } else {\n        break;\n      }\n    }\n\n    properties.descent = i - baseline;\n    properties.fontSize = properties.ascent + properties.descent;\n    Text.fontPropertiesCache[fontStyle] = properties;\n  }\n\n  return properties;\n};\n/**\n * Applies newlines to a string to have it optimally fit into the horizontal\n * bounds set by the Text object's wordWrapWidth property.\n *\n * @param text {string}\n * @private\n */\n\n\nText.prototype.wordWrap = function (text) {\n  // Greedy wrapping algorithm that will wrap words as the line grows longer\n  // than its horizontal bounds.\n  var result = '';\n  var lines = text.split('\\n');\n  var wordWrapWidth = this._style.wordWrapWidth;\n\n  for (var i = 0; i < lines.length; i++) {\n    var spaceLeft = wordWrapWidth;\n    var words = lines[i].split(' ');\n\n    for (var j = 0; j < words.length; j++) {\n      var wordWidth = this.context.measureText(words[j]).width;\n      var wordWidthWithSpace = wordWidth + this.context.measureText(' ').width;\n\n      if (j === 0 || wordWidthWithSpace > spaceLeft) {\n        // Skip printing the newline if it's the first word of the line that is\n        // greater than the word wrap width.\n        if (j > 0) {\n          result += '\\n';\n        }\n\n        result += words[j];\n        spaceLeft = wordWrapWidth - wordWidth;\n      } else {\n        spaceLeft -= wordWidthWithSpace;\n        result += ' ' + words[j];\n      }\n    }\n\n    if (i < lines.length - 1) {\n      result += '\\n';\n    }\n  }\n\n  return result;\n};\n/**\n * Returns the bounds of the Text as a rectangle. The bounds calculation takes the worldTransform into account.\n *\n * @param matrix {Matrix} the transformation matrix of the Text\n * @return {Rectangle} the framing rectangle\n */\n\n\nText.prototype.getBounds = function (matrix) {\n  if (this.dirty) {\n    this.updateText();\n  }\n\n  return Sprite.prototype.getBounds.call(this, matrix);\n};\n/**\n * Destroys this text object.\n *\n * @param [destroyBaseTexture=true] {boolean} whether to destroy the base texture as well\n */\n\n\nText.prototype.destroy = function (destroyBaseTexture) {\n  // make sure to reset the the context and canvas.. dont want this hanging around in memory!\n  this.context = null;\n  this.canvas = null;\n  this._style = null;\n\n  this._texture.destroy(destroyBaseTexture === undefined ? true : destroyBaseTexture);\n};","map":{"version":3,"names":["Sprite","require","Texture","math","utils","CONST","Text","text","style","resolution","canvas","document","createElement","context","getContext","RESOLUTION","_text","_style","texture","fromCanvas","trim","Rectangle","call","prototype","Object","create","constructor","module","exports","fontPropertiesCache","fontPropertiesCanvas","fontPropertiesContext","defineProperties","width","get","dirty","updateText","scale","x","_texture","_frame","set","value","_width","height","y","_height","fill","hex2string","stroke","dropShadowColor","font","align","strokeThickness","wordWrap","wordWrapWidth","dropShadow","dropShadowAngle","Math","PI","dropShadowDistance","padding","textBaseline","lineJoin","miterLimit","toString","outputText","lines","split","lineWidths","Array","length","maxLineWidth","fontProperties","determineFontProperties","i","lineWidth","measureText","max","lineHeight","fontSize","navigator","isCocoonJS","clearRect","strokeStyle","linePositionX","linePositionY","fillStyle","xShadowOffset","cos","yShadowOffset","sin","ascent","fillText","strokeText","updateTexture","baseTexture","hasLoaded","crop","emit","renderWebGL","renderer","_renderCanvas","fontStyle","properties","ceil","baseline","fillRect","imagedata","getImageData","data","pixels","line","j","idx","stop","descent","result","spaceLeft","words","wordWidth","wordWidthWithSpace","getBounds","matrix","destroy","destroyBaseTexture","undefined"],"sources":["/home/reyden-martin/Documents/Tech2/HUB/Sony CSL/SONY-CSL-PROJECT/node_modules/react-piano-roll/node_modules/pixi.js/src/core/text/Text.js"],"sourcesContent":["var Sprite = require('../sprites/Sprite'),\n    Texture = require('../textures/Texture'),\n    math = require('../math'),\n    utils = require('../utils'),\n    CONST = require('../const');\n\n/**\n * A Text Object will create a line or multiple lines of text. To split a line you can use '\\n' in your text string,\n * or add a wordWrap property set to true and and wordWrapWidth property with a value in the style object.\n *\n * A Text can be created directly from a string and a style object\n *\n * ```js\n * var text = new PIXI.Text('This is a pixi text',{font : '24px Arial', fill : 0xff1010, align : 'center'});\n * ```\n *\n * @class\n * @extends PIXI.Sprite\n * @memberof PIXI\n * @param text {string} The copy that you would like the text to display\n * @param [style] {object} The style parameters\n * @param [style.font] {string} default 'bold 20px Arial' The style and size of the font\n * @param [style.fill='black'] {String|Number} A canvas fillstyle that will be used on the text e.g 'red', '#00FF00'\n * @param [style.align='left'] {string} Alignment for multiline text ('left', 'center' or 'right'), does not affect single line text\n * @param [style.stroke] {String|Number} A canvas fillstyle that will be used on the text stroke e.g 'blue', '#FCFF00'\n * @param [style.strokeThickness=0] {number} A number that represents the thickness of the stroke. Default is 0 (no stroke)\n * @param [style.wordWrap=false] {boolean} Indicates if word wrap should be used\n * @param [style.wordWrapWidth=100] {number} The width at which text will wrap, it needs wordWrap to be set to true\n * @param [style.lineHeight] {number} The line height, a number that represents the vertical space that a letter uses\n * @param [style.dropShadow=false] {boolean} Set a drop shadow for the text\n * @param [style.dropShadowColor='#000000'] {string} A fill style to be used on the dropshadow e.g 'red', '#00FF00'\n * @param [style.dropShadowAngle=Math.PI/4] {number} Set a angle of the drop shadow\n * @param [style.dropShadowDistance=5] {number} Set a distance of the drop shadow\n * @param [style.padding=0] {number} Occasionally some fonts are cropped on top or bottom. Adding some padding will\n *      prevent this from happening by adding padding to the top and bottom of text height.\n * @param [style.textBaseline='alphabetic'] {string} The baseline of the text that is rendered.\n * @param [style.lineJoin='miter'] {string} The lineJoin property sets the type of corner created, it can resolve\n *      spiked text issues. Default is 'miter' (creates a sharp corner).\n * @param [style.miterLimit=10] {number} The miter limit to use when using the 'miter' lineJoin mode. This can reduce\n *      or increase the spikiness of rendered text.\n */\nfunction Text(text, style, resolution)\n{\n    /**\n     * The canvas element that everything is drawn to\n     *\n     * @member {HTMLCanvasElement}\n     */\n    this.canvas = document.createElement('canvas');\n\n    /**\n     * The canvas 2d context that everything is drawn with\n     * @member {HTMLCanvasElement}\n     */\n    this.context = this.canvas.getContext('2d');\n\n    /**\n     * The resolution of the canvas.\n     * @member {number}\n     */\n    this.resolution = resolution || CONST.RESOLUTION;\n\n    /**\n     * Private tracker for the current text.\n     *\n     * @member {string}\n     * @private\n     */\n    this._text = null;\n\n    /**\n     * Private tracker for the current style.\n     *\n     * @member {object}\n     * @private\n     */\n    this._style = null;\n\n    var texture = Texture.fromCanvas(this.canvas);\n    texture.trim = new math.Rectangle();\n    Sprite.call(this, texture);\n\n    this.text = text;\n    this.style = style;\n}\n\n// constructor\nText.prototype = Object.create(Sprite.prototype);\nText.prototype.constructor = Text;\nmodule.exports = Text;\n\nText.fontPropertiesCache = {};\nText.fontPropertiesCanvas = document.createElement('canvas');\nText.fontPropertiesContext = Text.fontPropertiesCanvas.getContext('2d');\n\nObject.defineProperties(Text.prototype, {\n    /**\n     * The width of the Text, setting this will actually modify the scale to achieve the value set\n     *\n     * @member {number}\n     * @memberof Text#\n     */\n    width: {\n        get: function ()\n        {\n            if (this.dirty)\n            {\n                this.updateText();\n            }\n\n            return this.scale.x * this._texture._frame.width;\n        },\n        set: function (value)\n        {\n            this.scale.x = value / this._texture._frame.width;\n            this._width = value;\n        }\n    },\n\n    /**\n     * The height of the Text, setting this will actually modify the scale to achieve the value set\n     *\n     * @member {number}\n     * @memberof Text#\n     */\n    height: {\n        get: function ()\n        {\n            if (this.dirty)\n            {\n                this.updateText();\n            }\n\n            return  this.scale.y * this._texture._frame.height;\n        },\n        set: function (value)\n        {\n            this.scale.y = value / this._texture._frame.height;\n            this._height = value;\n        }\n    },\n\n    /**\n     * Set the style of the text\n     *\n     * @param [style] {object} The style parameters\n     * @param [style.font='bold 20pt Arial'] {string} The style and size of the font\n     * @param [style.fill='black'] {string|number} A canvas fillstyle that will be used on the text eg 'red', '#00FF00'\n     * @param [style.align='left'] {string} Alignment for multiline text ('left', 'center' or 'right'), does not affect single line text\n     * @param [style.stroke='black'] {string|number} A canvas fillstyle that will be used on the text stroke eg 'blue', '#FCFF00'\n     * @param [style.strokeThickness=0] {number} A number that represents the thickness of the stroke. Default is 0 (no stroke)\n     * @param [style.wordWrap=false] {boolean} Indicates if word wrap should be used\n     * @param [style.wordWrapWidth=100] {number} The width at which text will wrap\n     * @param [style.lineHeight] {number} The line height, a number that represents the vertical space that a letter uses\n     * @param [style.dropShadow=false] {boolean} Set a drop shadow for the text\n     * @param [style.dropShadowColor='#000000'] {string|number} A fill style to be used on the dropshadow e.g 'red', '#00FF00'\n     * @param [style.dropShadowAngle=Math.PI/6] {number} Set a angle of the drop shadow\n     * @param [style.dropShadowDistance=5] {number} Set a distance of the drop shadow\n     * @param [style.padding=0] {number} Occasionally some fonts are cropped on top or bottom. Adding some padding will\n     *      prevent this from happening by adding padding to the top and bottom of text height.\n     * @param [style.textBaseline='alphabetic'] {string} The baseline of the text that is rendered.\n     * @param [style.lineJoin='miter'] {string} The lineJoin property sets the type of corner created, it can resolve\n     *      spiked text issues. Default is 'miter' (creates a sharp corner).\n     * @param [style.miterLimit=10] {number} The miter limit to use when using the 'miter' lineJoin mode. This can reduce\n     *      or increase the spikiness of rendered text.\n     * @memberof Text#\n     */\n    style: {\n        get: function ()\n        {\n            return this._style;\n        },\n        set: function (style)\n        {\n            style = style || {};\n\n            if (typeof style.fill === 'number') {\n                style.fill = utils.hex2string(style.fill);\n            }\n\n            if (typeof style.stroke === 'number') {\n                style.stroke = utils.hex2string(style.stroke);\n            }\n\n            if (typeof style.dropShadowColor === 'number') {\n                style.dropShadowColor = utils.hex2string(style.dropShadowColor);\n            }\n\n            style.font = style.font || 'bold 20pt Arial';\n            style.fill = style.fill || 'black';\n            style.align = style.align || 'left';\n            style.stroke = style.stroke || 'black'; //provide a default, see: https://github.com/GoodBoyDigital/pixi.js/issues/136\n            style.strokeThickness = style.strokeThickness || 0;\n            style.wordWrap = style.wordWrap || false;\n            style.wordWrapWidth = style.wordWrapWidth || 100;\n\n            style.dropShadow = style.dropShadow || false;\n            style.dropShadowColor = style.dropShadowColor || '#000000';\n            style.dropShadowAngle = style.dropShadowAngle || Math.PI / 6;\n            style.dropShadowDistance = style.dropShadowDistance || 5;\n\n            style.padding = style.padding || 0;\n\n            style.textBaseline = style.textBaseline || 'alphabetic';\n\n            style.lineJoin = style.lineJoin || 'miter';\n            style.miterLimit = style.miterLimit || 10;\n\n            this._style = style;\n            this.dirty = true;\n        }\n    },\n\n    /**\n     * Set the copy for the text object. To split a line you can use '\\n'.\n     *\n     * @param text {string} The copy that you would like the text to display\n     * @memberof Text#\n     */\n    text: {\n        get: function()\n        {\n            return this._text;\n        },\n        set: function (text){\n            text = text.toString() || ' ';\n            if (this._text === text)\n            {\n                return;\n            }\n            this._text = text;\n            this.dirty = true;\n        }\n    }\n});\n\n/**\n * Renders text and updates it when needed\n *\n * @private\n */\nText.prototype.updateText = function ()\n{\n    var style = this._style;\n    this.context.font = style.font;\n\n    // word wrap\n    // preserve original text\n    var outputText = style.wordWrap ? this.wordWrap(this._text) : this._text;\n\n    // split text into lines\n    var lines = outputText.split(/(?:\\r\\n|\\r|\\n)/);\n\n    // calculate text width\n    var lineWidths = new Array(lines.length);\n    var maxLineWidth = 0;\n    var fontProperties = this.determineFontProperties(style.font);\n    for (var i = 0; i < lines.length; i++)\n    {\n        var lineWidth = this.context.measureText(lines[i]).width;\n        lineWidths[i] = lineWidth;\n        maxLineWidth = Math.max(maxLineWidth, lineWidth);\n    }\n\n    var width = maxLineWidth + style.strokeThickness;\n    if (style.dropShadow)\n    {\n        width += style.dropShadowDistance;\n    }\n\n    this.canvas.width = ( width + this.context.lineWidth ) * this.resolution;\n\n    // calculate text height\n    var lineHeight = this.style.lineHeight || fontProperties.fontSize + style.strokeThickness;\n\n    var height = lineHeight * lines.length;\n    if (style.dropShadow)\n    {\n        height += style.dropShadowDistance;\n    }\n\n    this.canvas.height = ( height + this._style.padding * 2 ) * this.resolution;\n\n    this.context.scale( this.resolution, this.resolution);\n\n    if (navigator.isCocoonJS)\n    {\n        this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);\n\n    }\n\n    //this.context.fillStyle=\"#FF0000\";\n    //this.context.fillRect(0, 0, this.canvas.width, this.canvas.height);\n\n    this.context.font = style.font;\n    this.context.strokeStyle = style.stroke;\n    this.context.lineWidth = style.strokeThickness;\n    this.context.textBaseline = style.textBaseline;\n    this.context.lineJoin = style.lineJoin;\n    this.context.miterLimit = style.miterLimit;\n\n    var linePositionX;\n    var linePositionY;\n\n    if (style.dropShadow)\n    {\n        this.context.fillStyle = style.dropShadowColor;\n\n        var xShadowOffset = Math.cos(style.dropShadowAngle) * style.dropShadowDistance;\n        var yShadowOffset = Math.sin(style.dropShadowAngle) * style.dropShadowDistance;\n\n        for (i = 0; i < lines.length; i++)\n        {\n            linePositionX = style.strokeThickness / 2;\n            linePositionY = (style.strokeThickness / 2 + i * lineHeight) + fontProperties.ascent;\n\n            if (style.align === 'right')\n            {\n                linePositionX += maxLineWidth - lineWidths[i];\n            }\n            else if (style.align === 'center')\n            {\n                linePositionX += (maxLineWidth - lineWidths[i]) / 2;\n            }\n\n            if (style.fill)\n            {\n                this.context.fillText(lines[i], linePositionX + xShadowOffset, linePositionY + yShadowOffset + this._style.padding);\n            }\n        }\n    }\n\n    //set canvas text styles\n    this.context.fillStyle = style.fill;\n\n    //draw lines line by line\n    for (i = 0; i < lines.length; i++)\n    {\n        linePositionX = style.strokeThickness / 2;\n        linePositionY = (style.strokeThickness / 2 + i * lineHeight) + fontProperties.ascent;\n\n        if (style.align === 'right')\n        {\n            linePositionX += maxLineWidth - lineWidths[i];\n        }\n        else if (style.align === 'center')\n        {\n            linePositionX += (maxLineWidth - lineWidths[i]) / 2;\n        }\n\n        if (style.stroke && style.strokeThickness)\n        {\n            this.context.strokeText(lines[i], linePositionX, linePositionY + this._style.padding);\n        }\n\n        if (style.fill)\n        {\n            this.context.fillText(lines[i], linePositionX, linePositionY + this._style.padding);\n        }\n    }\n\n    this.updateTexture();\n};\n\n/**\n * Updates texture size based on canvas size\n *\n * @private\n */\nText.prototype.updateTexture = function ()\n{\n    var texture = this._texture;\n\n    texture.baseTexture.hasLoaded = true;\n    texture.baseTexture.resolution = this.resolution;\n\n    texture.baseTexture.width = this.canvas.width / this.resolution;\n    texture.baseTexture.height = this.canvas.height / this.resolution;\n    texture.crop.width = texture._frame.width = this.canvas.width / this.resolution;\n    texture.crop.height = texture._frame.height = this.canvas.height / this.resolution;\n\n    texture.trim.x = 0;\n    texture.trim.y = -this._style.padding;\n\n    texture.trim.width = texture._frame.width;\n    texture.trim.height = texture._frame.height - this._style.padding*2;\n\n    this._width = this.canvas.width / this.resolution;\n    this._height = this.canvas.height / this.resolution;\n\n    texture.baseTexture.emit('update',  texture.baseTexture);\n\n    this.dirty = false;\n};\n\n/**\n * Renders the object using the WebGL renderer\n *\n * @param renderer {WebGLRenderer}\n */\nText.prototype.renderWebGL = function (renderer)\n{\n    if (this.dirty)\n    {\n        //this.resolution = 1//renderer.resolution;\n\n        this.updateText();\n    }\n\n    Sprite.prototype.renderWebGL.call(this, renderer);\n};\n\n/**\n * Renders the object using the Canvas renderer\n *\n * @param renderer {CanvasRenderer}\n * @private\n */\nText.prototype._renderCanvas = function (renderer)\n{\n    if (this.dirty)\n    {\n     //   this.resolution = 1//renderer.resolution;\n\n        this.updateText();\n    }\n\n    Sprite.prototype._renderCanvas.call(this, renderer);\n};\n\n/**\n * Calculates the ascent, descent and fontSize of a given fontStyle\n *\n * @param fontStyle {object}\n * @private\n */\nText.prototype.determineFontProperties = function (fontStyle)\n{\n    var properties = Text.fontPropertiesCache[fontStyle];\n\n    if (!properties)\n    {\n        properties = {};\n\n        var canvas = Text.fontPropertiesCanvas;\n        var context = Text.fontPropertiesContext;\n\n        context.font = fontStyle;\n\n        var width = Math.ceil(context.measureText('|MÉq').width);\n        var baseline = Math.ceil(context.measureText('M').width);\n        var height = 2 * baseline;\n\n        baseline = baseline * 1.4 | 0;\n\n        canvas.width = width;\n        canvas.height = height;\n\n        context.fillStyle = '#f00';\n        context.fillRect(0, 0, width, height);\n\n        context.font = fontStyle;\n\n        context.textBaseline = 'alphabetic';\n        context.fillStyle = '#000';\n        context.fillText('|MÉq', 0, baseline);\n\n        var imagedata = context.getImageData(0, 0, width, height).data;\n        var pixels = imagedata.length;\n        var line = width * 4;\n\n        var i, j;\n\n        var idx = 0;\n        var stop = false;\n\n        // ascent. scan from top to bottom until we find a non red pixel\n        for (i = 0; i < baseline; i++)\n        {\n            for (j = 0; j < line; j += 4)\n            {\n                if (imagedata[idx + j] !== 255)\n                {\n                    stop = true;\n                    break;\n                }\n            }\n            if (!stop)\n            {\n                idx += line;\n            }\n            else\n            {\n                break;\n            }\n        }\n\n        properties.ascent = baseline - i;\n\n        idx = pixels - line;\n        stop = false;\n\n        // descent. scan from bottom to top until we find a non red pixel\n        for (i = height; i > baseline; i--)\n        {\n            for (j = 0; j < line; j += 4)\n            {\n                if (imagedata[idx + j] !== 255)\n                {\n                    stop = true;\n                    break;\n                }\n            }\n            if (!stop)\n            {\n                idx -= line;\n            }\n            else\n            {\n                break;\n            }\n        }\n\n        properties.descent = i - baseline;\n        properties.fontSize = properties.ascent + properties.descent;\n\n        Text.fontPropertiesCache[fontStyle] = properties;\n    }\n\n    return properties;\n};\n\n/**\n * Applies newlines to a string to have it optimally fit into the horizontal\n * bounds set by the Text object's wordWrapWidth property.\n *\n * @param text {string}\n * @private\n */\nText.prototype.wordWrap = function (text)\n{\n    // Greedy wrapping algorithm that will wrap words as the line grows longer\n    // than its horizontal bounds.\n    var result = '';\n    var lines = text.split('\\n');\n    var wordWrapWidth = this._style.wordWrapWidth;\n    for (var i = 0; i < lines.length; i++)\n    {\n        var spaceLeft = wordWrapWidth;\n        var words = lines[i].split(' ');\n        for (var j = 0; j < words.length; j++)\n        {\n            var wordWidth = this.context.measureText(words[j]).width;\n            var wordWidthWithSpace = wordWidth + this.context.measureText(' ').width;\n            if (j === 0 || wordWidthWithSpace > spaceLeft)\n            {\n                // Skip printing the newline if it's the first word of the line that is\n                // greater than the word wrap width.\n                if (j > 0)\n                {\n                    result += '\\n';\n                }\n                result += words[j];\n                spaceLeft = wordWrapWidth - wordWidth;\n            }\n            else\n            {\n                spaceLeft -= wordWidthWithSpace;\n                result += ' ' + words[j];\n            }\n        }\n\n        if (i < lines.length-1)\n        {\n            result += '\\n';\n        }\n    }\n    return result;\n};\n\n/**\n * Returns the bounds of the Text as a rectangle. The bounds calculation takes the worldTransform into account.\n *\n * @param matrix {Matrix} the transformation matrix of the Text\n * @return {Rectangle} the framing rectangle\n */\nText.prototype.getBounds = function (matrix)\n{\n    if (this.dirty)\n    {\n        this.updateText();\n    }\n\n    return Sprite.prototype.getBounds.call(this, matrix);\n};\n\n/**\n * Destroys this text object.\n *\n * @param [destroyBaseTexture=true] {boolean} whether to destroy the base texture as well\n */\nText.prototype.destroy = function (destroyBaseTexture)\n{\n    // make sure to reset the the context and canvas.. dont want this hanging around in memory!\n    this.context = null;\n    this.canvas = null;\n\n    this._style = null;\n\n    this._texture.destroy(destroyBaseTexture === undefined ? true : destroyBaseTexture);\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}