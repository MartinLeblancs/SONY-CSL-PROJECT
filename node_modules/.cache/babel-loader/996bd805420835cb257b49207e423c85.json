{"ast":null,"code":"var CONST = require('../const'),\n    EventEmitter = require('eventemitter3'),\n    // Internal event used by composed emitter\nTICK = 'tick';\n/**\n * A Ticker class that runs an update loop that other objects listen to.\n * This class is composed around an EventEmitter object to add listeners\n * meant for execution on the next requested animation frame.\n * Animation frames are requested only when necessary,\n * e.g. When the ticker is started and the emitter has listeners.\n *\n * @class\n * @memberof PIXI.ticker\n */\n\n\nfunction Ticker() {\n  var _this = this;\n  /**\n   * Internal tick method bound to ticker instance.\n   * This is because in early 2015, Function.bind\n   * is still 60% slower in high performance scenarios.\n   * Also separating frame requests from update method\n   * so listeners may be called at any time and with\n   * any animation API, just invoke ticker.update(time).\n   *\n   * @private\n   */\n\n\n  this._tick = function _tick(time) {\n    _this._requestId = null;\n\n    if (_this.started) {\n      // Invoke listeners now\n      _this.update(time); // Listener side effects may have modified ticker state.\n\n\n      if (_this.started && _this._requestId === null && _this._emitter.listeners(TICK, true)) {\n        _this._requestId = requestAnimationFrame(_this._tick);\n      }\n    }\n  };\n  /**\n   * Internal emitter used to fire 'tick' event\n   * @private\n   */\n\n\n  this._emitter = new EventEmitter();\n  /**\n   * Internal current frame request ID\n   * @private\n   */\n\n  this._requestId = null;\n  /**\n   * Internal value managed by minFPS property setter and getter.\n   * This is the maximum allowed milliseconds between updates.\n   * @private\n   */\n\n  this._maxElapsedMS = 100;\n  /**\n   * Whether or not this ticker should invoke the method\n   * {@link PIXI.ticker.Ticker#start} automatically\n   * when a listener is added.\n   *\n   * @member {boolean}\n   * @default false\n   */\n\n  this.autoStart = false;\n  /**\n   * Scalar time value from last frame to this frame.\n   * This value is capped by setting {@link PIXI.ticker.Ticker#minFPS}\n   * and is scaled with {@link PIXI.ticker.Ticker#speed}.\n   * **Note:** The cap may be exceeded by scaling.\n   *\n   * @member {number}\n   * @default 1\n   */\n\n  this.deltaTime = 1;\n  /**\n   * Time elapsed in milliseconds from last frame to this frame.\n   * Opposed to what the scalar {@link PIXI.ticker.Ticker#deltaTime}\n   * is based, this value is neither capped nor scaled.\n   * If the platform supports DOMHighResTimeStamp,\n   * this value will have a precision of 1 µs.\n   *\n   * @member {DOMHighResTimeStamp|number}\n   * @default 1 / TARGET_FPMS\n   */\n\n  this.elapsedMS = 1 / CONST.TARGET_FPMS; // default to target frame time\n\n  /**\n   * The last time {@link PIXI.ticker.Ticker#update} was invoked.\n   * This value is also reset internally outside of invoking\n   * update, but only when a new animation frame is requested.\n   * If the platform supports DOMHighResTimeStamp,\n   * this value will have a precision of 1 µs.\n   *\n   * @member {DOMHighResTimeStamp|number}\n   * @default 0\n   */\n\n  this.lastTime = 0;\n  /**\n   * Factor of current {@link PIXI.ticker.Ticker#deltaTime}.\n   * @example\n   *     // Scales ticker.deltaTime to what would be\n   *     // the equivalent of approximately 120 FPS\n   *     ticker.speed = 2;\n   *\n   * @member {number}\n   * @default 1\n   */\n\n  this.speed = 1;\n  /**\n   * Whether or not this ticker has been started.\n   * `true` if {@link PIXI.ticker.Ticker#start} has been called.\n   * `false` if {@link PIXI.ticker.Ticker#stop} has been called.\n   * While `false`, this value may change to `true` in the\n   * event of {@link PIXI.ticker.Ticker#autoStart} being `true`\n   * and a listener is added.\n   *\n   * @member {boolean}\n   * @default false\n   */\n\n  this.started = false;\n}\n\nObject.defineProperties(Ticker.prototype, {\n  /**\n   * The frames per second at which this ticker is running.\n   * The default is approximately 60 in most modern browsers.\n   * **Note:** This does not factor in the value of\n   * {@link PIXI.ticker.Ticker#speed}, which is specific\n   * to scaling {@link PIXI.ticker.Ticker#deltaTime}.\n   *\n   * @member\n   * @memberof PIXI.ticker.Ticker#\n   * @readonly\n   */\n  FPS: {\n    get: function () {\n      return 1000 / this.elapsedMS;\n    }\n  },\n\n  /**\n   * Manages the maximum amount of milliseconds allowed to\n   * elapse between invoking {@link PIXI.ticker.Ticker#update}.\n   * This value is used to cap {@link PIXI.ticker.Ticker#deltaTime},\n   * but does not effect the measured value of {@link PIXI.ticker.Ticker#FPS}.\n   * When setting this property it is clamped to a value between\n   * `0` and `PIXI.TARGET_FPMS * 1000`.\n   *\n   * @member\n   * @memberof PIXI.ticker.Ticker#\n   * @default 10\n   */\n  minFPS: {\n    get: function () {\n      return 1000 / this._maxElapsedMS;\n    },\n    set: function (fps) {\n      // Clamp: 0 to TARGET_FPMS\n      var minFPMS = Math.min(Math.max(0, fps) / 1000, CONST.TARGET_FPMS);\n      this._maxElapsedMS = 1 / minFPMS;\n    }\n  }\n});\n/**\n * Conditionally requests a new animation frame.\n * If a frame has not already been requested, and if the internal\n * emitter has listeners, a new frame is requested.\n *\n * @private\n */\n\nTicker.prototype._requestIfNeeded = function _requestIfNeeded() {\n  if (this._requestId === null && this._emitter.listeners(TICK, true)) {\n    // ensure callbacks get correct delta\n    this.lastTime = performance.now();\n    this._requestId = requestAnimationFrame(this._tick);\n  }\n};\n/**\n * Conditionally cancels a pending animation frame.\n *\n * @private\n */\n\n\nTicker.prototype._cancelIfNeeded = function _cancelIfNeeded() {\n  if (this._requestId !== null) {\n    cancelAnimationFrame(this._requestId);\n    this._requestId = null;\n  }\n};\n/**\n * Conditionally requests a new animation frame.\n * If the ticker has been started it checks if a frame has not already\n * been requested, and if the internal emitter has listeners. If these\n * conditions are met, a new frame is requested. If the ticker has not\n * been started, but autoStart is `true`, then the ticker starts now,\n * and continues with the previous conditions to request a new frame.\n *\n * @private\n */\n\n\nTicker.prototype._startIfPossible = function _startIfPossible() {\n  if (this.started) {\n    this._requestIfNeeded();\n  } else if (this.autoStart) {\n    this.start();\n  }\n};\n/**\n * Calls {@link module:eventemitter3.EventEmitter#on} internally for the\n * internal 'tick' event. It checks if the emitter has listeners,\n * and if so it requests a new animation frame at this point.\n *\n * @param fn {Function} The listener function to be added for updates\n * @param [context] {Function} The listener context\n * @returns {PIXI.ticker.Ticker} this\n */\n\n\nTicker.prototype.add = function add(fn, context) {\n  this._emitter.on(TICK, fn, context);\n\n  this._startIfPossible();\n\n  return this;\n};\n/**\n * Calls {@link module:eventemitter3.EventEmitter#once} internally for the\n * internal 'tick' event. It checks if the emitter has listeners,\n * and if so it requests a new animation frame at this point.\n *\n * @param fn {Function} The listener function to be added for one update\n * @param [context] {Function} The listener context\n * @returns {PIXI.ticker.Ticker} this\n */\n\n\nTicker.prototype.addOnce = function addOnce(fn, context) {\n  this._emitter.once(TICK, fn, context);\n\n  this._startIfPossible();\n\n  return this;\n};\n/**\n * Calls {@link module:eventemitter3.EventEmitter#off} internally for 'tick' event.\n * It checks if the emitter has listeners for 'tick' event.\n * If it does, then it cancels the animation frame.\n *\n * @param [fn] {Function} The listener function to be removed\n * @param [context] {Function} The listener context to be removed\n * @returns {PIXI.ticker.Ticker} this\n */\n\n\nTicker.prototype.remove = function remove(fn, context) {\n  this._emitter.off(TICK, fn, context);\n\n  if (!this._emitter.listeners(TICK, true)) {\n    this._cancelIfNeeded();\n  }\n\n  return this;\n};\n/**\n * Starts the ticker. If the ticker has listeners\n * a new animation frame is requested at this point.\n */\n\n\nTicker.prototype.start = function start() {\n  if (!this.started) {\n    this.started = true;\n\n    this._requestIfNeeded();\n  }\n};\n/**\n * Stops the ticker. If the ticker has requested\n * an animation frame it is canceled at this point.\n */\n\n\nTicker.prototype.stop = function stop() {\n  if (this.started) {\n    this.started = false;\n\n    this._cancelIfNeeded();\n  }\n};\n/**\n * Triggers an update. An update entails setting the\n * current {@link PIXI.ticker.Ticker#elapsedMS},\n * the current {@link PIXI.ticker.Ticker#deltaTime},\n * invoking all listeners with current deltaTime,\n * and then finally setting {@link PIXI.ticker.Ticker#lastTime}\n * with the value of currentTime that was provided.\n * This method will be called automatically by animation\n * frame callbacks if the ticker instance has been started\n * and listeners are added.\n *\n * @param [currentTime=performance.now()] {DOMHighResTimeStamp|number} the current time of execution\n */\n\n\nTicker.prototype.update = function update(currentTime) {\n  var elapsedMS; // Allow calling update directly with default currentTime.\n\n  currentTime = currentTime || performance.now(); // Save uncapped elapsedMS for measurement\n\n  elapsedMS = this.elapsedMS = currentTime - this.lastTime; // cap the milliseconds elapsed used for deltaTime\n\n  if (elapsedMS > this._maxElapsedMS) {\n    elapsedMS = this._maxElapsedMS;\n  }\n\n  this.deltaTime = elapsedMS * CONST.TARGET_FPMS * this.speed; // Invoke listeners added to internal emitter\n\n  this._emitter.emit(TICK, this.deltaTime);\n\n  this.lastTime = currentTime;\n};\n\nmodule.exports = Ticker;","map":{"version":3,"names":["CONST","require","EventEmitter","TICK","Ticker","_this","_tick","time","_requestId","started","update","_emitter","listeners","requestAnimationFrame","_maxElapsedMS","autoStart","deltaTime","elapsedMS","TARGET_FPMS","lastTime","speed","Object","defineProperties","prototype","FPS","get","minFPS","set","fps","minFPMS","Math","min","max","_requestIfNeeded","performance","now","_cancelIfNeeded","cancelAnimationFrame","_startIfPossible","start","add","fn","context","on","addOnce","once","remove","off","stop","currentTime","emit","module","exports"],"sources":["/home/reyden-martin/Documents/Tech2/HUB/Sony CSL/SONY-CSL-PROJECT/node_modules/react-piano-roll/node_modules/pixi.js/src/core/ticker/Ticker.js"],"sourcesContent":["var CONST = require('../const'),\n    EventEmitter = require('eventemitter3'),\n    // Internal event used by composed emitter\n    TICK = 'tick';\n\n/**\n * A Ticker class that runs an update loop that other objects listen to.\n * This class is composed around an EventEmitter object to add listeners\n * meant for execution on the next requested animation frame.\n * Animation frames are requested only when necessary,\n * e.g. When the ticker is started and the emitter has listeners.\n *\n * @class\n * @memberof PIXI.ticker\n */\nfunction Ticker()\n{\n    var _this = this;\n    /**\n     * Internal tick method bound to ticker instance.\n     * This is because in early 2015, Function.bind\n     * is still 60% slower in high performance scenarios.\n     * Also separating frame requests from update method\n     * so listeners may be called at any time and with\n     * any animation API, just invoke ticker.update(time).\n     *\n     * @private\n     */\n    this._tick = function _tick(time) {\n\n        _this._requestId = null;\n\n        if (_this.started)\n        {\n            // Invoke listeners now\n            _this.update(time);\n            // Listener side effects may have modified ticker state.\n            if (_this.started && _this._requestId === null && _this._emitter.listeners(TICK, true))\n            {\n                _this._requestId = requestAnimationFrame(_this._tick);\n            }\n        }\n    };\n    /**\n     * Internal emitter used to fire 'tick' event\n     * @private\n     */\n    this._emitter = new EventEmitter();\n    /**\n     * Internal current frame request ID\n     * @private\n     */\n    this._requestId = null;\n    /**\n     * Internal value managed by minFPS property setter and getter.\n     * This is the maximum allowed milliseconds between updates.\n     * @private\n     */\n    this._maxElapsedMS = 100;\n\n    /**\n     * Whether or not this ticker should invoke the method\n     * {@link PIXI.ticker.Ticker#start} automatically\n     * when a listener is added.\n     *\n     * @member {boolean}\n     * @default false\n     */\n    this.autoStart = false;\n\n    /**\n     * Scalar time value from last frame to this frame.\n     * This value is capped by setting {@link PIXI.ticker.Ticker#minFPS}\n     * and is scaled with {@link PIXI.ticker.Ticker#speed}.\n     * **Note:** The cap may be exceeded by scaling.\n     *\n     * @member {number}\n     * @default 1\n     */\n    this.deltaTime = 1;\n\n    /**\n     * Time elapsed in milliseconds from last frame to this frame.\n     * Opposed to what the scalar {@link PIXI.ticker.Ticker#deltaTime}\n     * is based, this value is neither capped nor scaled.\n     * If the platform supports DOMHighResTimeStamp,\n     * this value will have a precision of 1 µs.\n     *\n     * @member {DOMHighResTimeStamp|number}\n     * @default 1 / TARGET_FPMS\n     */\n    this.elapsedMS = 1 / CONST.TARGET_FPMS; // default to target frame time\n\n    /**\n     * The last time {@link PIXI.ticker.Ticker#update} was invoked.\n     * This value is also reset internally outside of invoking\n     * update, but only when a new animation frame is requested.\n     * If the platform supports DOMHighResTimeStamp,\n     * this value will have a precision of 1 µs.\n     *\n     * @member {DOMHighResTimeStamp|number}\n     * @default 0\n     */\n    this.lastTime = 0;\n\n    /**\n     * Factor of current {@link PIXI.ticker.Ticker#deltaTime}.\n     * @example\n     *     // Scales ticker.deltaTime to what would be\n     *     // the equivalent of approximately 120 FPS\n     *     ticker.speed = 2;\n     *\n     * @member {number}\n     * @default 1\n     */\n    this.speed = 1;\n\n    /**\n     * Whether or not this ticker has been started.\n     * `true` if {@link PIXI.ticker.Ticker#start} has been called.\n     * `false` if {@link PIXI.ticker.Ticker#stop} has been called.\n     * While `false`, this value may change to `true` in the\n     * event of {@link PIXI.ticker.Ticker#autoStart} being `true`\n     * and a listener is added.\n     *\n     * @member {boolean}\n     * @default false\n     */\n    this.started = false;\n}\n\nObject.defineProperties(Ticker.prototype, {\n    /**\n     * The frames per second at which this ticker is running.\n     * The default is approximately 60 in most modern browsers.\n     * **Note:** This does not factor in the value of\n     * {@link PIXI.ticker.Ticker#speed}, which is specific\n     * to scaling {@link PIXI.ticker.Ticker#deltaTime}.\n     *\n     * @member\n     * @memberof PIXI.ticker.Ticker#\n     * @readonly\n     */\n    FPS: {\n        get: function()\n        {\n            return 1000 / this.elapsedMS;\n        }\n    },\n\n    /**\n     * Manages the maximum amount of milliseconds allowed to\n     * elapse between invoking {@link PIXI.ticker.Ticker#update}.\n     * This value is used to cap {@link PIXI.ticker.Ticker#deltaTime},\n     * but does not effect the measured value of {@link PIXI.ticker.Ticker#FPS}.\n     * When setting this property it is clamped to a value between\n     * `0` and `PIXI.TARGET_FPMS * 1000`.\n     *\n     * @member\n     * @memberof PIXI.ticker.Ticker#\n     * @default 10\n     */\n    minFPS: {\n        get: function()\n        {\n            return 1000 / this._maxElapsedMS;\n        },\n        set: function(fps)\n        {\n            // Clamp: 0 to TARGET_FPMS\n            var minFPMS = Math.min(Math.max(0, fps) / 1000, CONST.TARGET_FPMS);\n            this._maxElapsedMS = 1 / minFPMS;\n        }\n    }\n});\n\n/**\n * Conditionally requests a new animation frame.\n * If a frame has not already been requested, and if the internal\n * emitter has listeners, a new frame is requested.\n *\n * @private\n */\nTicker.prototype._requestIfNeeded = function _requestIfNeeded()\n{\n    if (this._requestId === null && this._emitter.listeners(TICK, true))\n    {\n        // ensure callbacks get correct delta\n        this.lastTime = performance.now();\n        this._requestId = requestAnimationFrame(this._tick);\n    }\n};\n\n/**\n * Conditionally cancels a pending animation frame.\n *\n * @private\n */\nTicker.prototype._cancelIfNeeded = function _cancelIfNeeded()\n{\n    if (this._requestId !== null)\n    {\n        cancelAnimationFrame(this._requestId);\n        this._requestId = null;\n    }\n};\n\n/**\n * Conditionally requests a new animation frame.\n * If the ticker has been started it checks if a frame has not already\n * been requested, and if the internal emitter has listeners. If these\n * conditions are met, a new frame is requested. If the ticker has not\n * been started, but autoStart is `true`, then the ticker starts now,\n * and continues with the previous conditions to request a new frame.\n *\n * @private\n */\nTicker.prototype._startIfPossible = function _startIfPossible()\n{\n    if (this.started)\n    {\n        this._requestIfNeeded();\n    }\n    else if (this.autoStart)\n    {\n        this.start();\n    }\n};\n\n/**\n * Calls {@link module:eventemitter3.EventEmitter#on} internally for the\n * internal 'tick' event. It checks if the emitter has listeners,\n * and if so it requests a new animation frame at this point.\n *\n * @param fn {Function} The listener function to be added for updates\n * @param [context] {Function} The listener context\n * @returns {PIXI.ticker.Ticker} this\n */\nTicker.prototype.add = function add(fn, context)\n{\n    this._emitter.on(TICK, fn, context);\n\n    this._startIfPossible();\n\n    return this;\n};\n\n/**\n * Calls {@link module:eventemitter3.EventEmitter#once} internally for the\n * internal 'tick' event. It checks if the emitter has listeners,\n * and if so it requests a new animation frame at this point.\n *\n * @param fn {Function} The listener function to be added for one update\n * @param [context] {Function} The listener context\n * @returns {PIXI.ticker.Ticker} this\n */\nTicker.prototype.addOnce = function addOnce(fn, context)\n{\n    this._emitter.once(TICK, fn, context);\n\n    this._startIfPossible();\n\n    return this;\n};\n\n/**\n * Calls {@link module:eventemitter3.EventEmitter#off} internally for 'tick' event.\n * It checks if the emitter has listeners for 'tick' event.\n * If it does, then it cancels the animation frame.\n *\n * @param [fn] {Function} The listener function to be removed\n * @param [context] {Function} The listener context to be removed\n * @returns {PIXI.ticker.Ticker} this\n */\nTicker.prototype.remove = function remove(fn, context)\n{\n    this._emitter.off(TICK, fn, context);\n\n    if (!this._emitter.listeners(TICK, true))\n    {\n        this._cancelIfNeeded();\n    }\n\n    return this;\n};\n\n/**\n * Starts the ticker. If the ticker has listeners\n * a new animation frame is requested at this point.\n */\nTicker.prototype.start = function start()\n{\n    if (!this.started)\n    {\n        this.started = true;\n        this._requestIfNeeded();\n    }\n};\n\n/**\n * Stops the ticker. If the ticker has requested\n * an animation frame it is canceled at this point.\n */\nTicker.prototype.stop = function stop()\n{\n    if (this.started)\n    {\n        this.started = false;\n        this._cancelIfNeeded();\n    }\n};\n\n/**\n * Triggers an update. An update entails setting the\n * current {@link PIXI.ticker.Ticker#elapsedMS},\n * the current {@link PIXI.ticker.Ticker#deltaTime},\n * invoking all listeners with current deltaTime,\n * and then finally setting {@link PIXI.ticker.Ticker#lastTime}\n * with the value of currentTime that was provided.\n * This method will be called automatically by animation\n * frame callbacks if the ticker instance has been started\n * and listeners are added.\n *\n * @param [currentTime=performance.now()] {DOMHighResTimeStamp|number} the current time of execution\n */\nTicker.prototype.update = function update(currentTime)\n{\n    var elapsedMS;\n\n    // Allow calling update directly with default currentTime.\n    currentTime = currentTime || performance.now();\n    // Save uncapped elapsedMS for measurement\n    elapsedMS = this.elapsedMS = currentTime - this.lastTime;\n\n    // cap the milliseconds elapsed used for deltaTime\n    if (elapsedMS > this._maxElapsedMS)\n    {\n        elapsedMS = this._maxElapsedMS;\n    }\n\n    this.deltaTime = elapsedMS * CONST.TARGET_FPMS * this.speed;\n\n    // Invoke listeners added to internal emitter\n    this._emitter.emit(TICK, this.deltaTime);\n\n    this.lastTime = currentTime;\n};\n\nmodule.exports = Ticker;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}