{"ast":null,"code":"'use strict';\n\nvar EventEmitter = require('eventemitter3');\n\nvar parseUri = require('parse-uri'); // tests is CORS is supported in XHR, if not we need to use XDR\n\n\nvar useXdr = !!(window.XDomainRequest && !('withCredentials' in new XMLHttpRequest()));\nvar tempAnchor = null; // some status constants\n\nvar STATUS_NONE = 0;\nvar STATUS_OK = 200;\nvar STATUS_EMPTY = 204;\n/**\n * Manages the state and loading of a single resource represented by\n * a single URL.\n *\n * @class\n * @param {string} name - The name of the resource to load.\n * @param {string|string[]} url - The url for this resource, for audio/video loads you can pass an array of sources.\n * @param {object} [options] - The options for the load.\n * @param {string|boolean} [options.crossOrigin] - Is this request cross-origin? Default is to determine automatically.\n * @param {Resource.LOAD_TYPE} [options.loadType=Resource.LOAD_TYPE.XHR] - How should this resource be loaded?\n * @param {Resource.XHR_RESPONSE_TYPE} [options.xhrType=Resource.XHR_RESPONSE_TYPE.DEFAULT] - How should the data being\n *      loaded be interpreted when using XHR?\n * @param {object} [options.metadata] - Extra info for middleware.\n */\n\nfunction Resource(name, url, options) {\n  EventEmitter.call(this);\n  options = options || {};\n\n  if (typeof name !== 'string' || typeof url !== 'string') {\n    throw new Error('Both name and url are required for constructing a resource.');\n  }\n  /**\n   * The name of this resource.\n   *\n   * @member {string}\n   * @readonly\n   */\n\n\n  this.name = name;\n  /**\n   * The url used to load this resource.\n   *\n   * @member {string}\n   * @readonly\n   */\n\n  this.url = url;\n  /**\n   * Stores whether or not this url is a data url.\n   *\n   * @member {boolean}\n   * @readonly\n   */\n\n  this.isDataUrl = this.url.indexOf('data:') === 0;\n  /**\n   * The data that was loaded by the resource.\n   *\n   * @member {any}\n   */\n\n  this.data = null;\n  /**\n   * Is this request cross-origin? If unset, determined automatically.\n   *\n   * @member {string}\n   */\n\n  this.crossOrigin = options.crossOrigin === true ? 'anonymous' : options.crossOrigin;\n  /**\n   * The method of loading to use for this resource.\n   *\n   * @member {Resource.LOAD_TYPE}\n   */\n\n  this.loadType = options.loadType || this._determineLoadType();\n  /**\n   * The type used to load the resource via XHR. If unset, determined automatically.\n   *\n   * @member {string}\n   */\n\n  this.xhrType = options.xhrType;\n  /**\n   * Extra info for middleware, and controlling specifics about how the resource loads.\n   *\n   * Note that if you pass in a `loadElement`, the Resource class takes ownership of it.\n   * Meaning it will modify it as it sees fit.\n   *\n   * @member {object}\n   * @property {HTMLImageElement|HTMLAudioElement|HTMLVideoElement} [loadElement=null] - The\n   *  element to use for loading, instead of creating one.\n   * @property {boolean} [skipSource=false] - Skips adding source(s) to the load element. This\n   *  is useful if you want to pass in a `loadElement` that you already added load sources\n   *  to.\n   */\n\n  this.metadata = options.metadata || {};\n  /**\n   * The error that occurred while loading (if any).\n   *\n   * @member {Error}\n   * @readonly\n   */\n\n  this.error = null;\n  /**\n   * The XHR object that was used to load this resource. This is only set\n   * when `loadType` is `Resource.LOAD_TYPE.XHR`.\n   *\n   * @member {XMLHttpRequest}\n   */\n\n  this.xhr = null;\n  /**\n   * Describes if this resource was loaded as json. Only valid after the resource\n   * has completely loaded.\n   *\n   * @member {boolean}\n   */\n\n  this.isJson = false;\n  /**\n   * Describes if this resource was loaded as xml. Only valid after the resource\n   * has completely loaded.\n   *\n   * @member {boolean}\n   */\n\n  this.isXml = false;\n  /**\n   * Describes if this resource was loaded as an image tag. Only valid after the resource\n   * has completely loaded.\n   *\n   * @member {boolean}\n   */\n\n  this.isImage = false;\n  /**\n   * Describes if this resource was loaded as an audio tag. Only valid after the resource\n   * has completely loaded.\n   *\n   * @member {boolean}\n   */\n\n  this.isAudio = false;\n  /**\n   * Describes if this resource was loaded as a video tag. Only valid after the resource\n   * has completely loaded.\n   *\n   * @member {boolean}\n   */\n\n  this.isVideo = false;\n  /**\n   * Describes if this resource has finished loading. Is true when the resource has completely\n   * loaded.\n   *\n   * @member {boolean}\n   */\n\n  this.isComplete = false;\n  /**\n   * Describes if this resource is currently loading. Is true when the resource starts loading,\n   * and is false again when complete.\n   *\n   * @member {boolean}\n   */\n\n  this.isLoading = false;\n  /**\n   * The `dequeue` method that will be used a storage place for the async queue dequeue method\n   * used privately by the loader.\n   *\n   * @private\n   * @member {function}\n   */\n\n  this._dequeue = null;\n  /**\n   * The `complete` function bound to this resource's context.\n   *\n   * @private\n   * @member {function}\n   */\n\n  this._boundComplete = this.complete.bind(this);\n  /**\n   * The `_onError` function bound to this resource's context.\n   *\n   * @private\n   * @member {function}\n   */\n\n  this._boundOnError = this._onError.bind(this);\n  /**\n   * The `_onProgress` function bound to this resource's context.\n   *\n   * @private\n   * @member {function}\n   */\n\n  this._boundOnProgress = this._onProgress.bind(this); // xhr callbacks\n\n  this._boundXhrOnError = this._xhrOnError.bind(this);\n  this._boundXhrOnAbort = this._xhrOnAbort.bind(this);\n  this._boundXhrOnLoad = this._xhrOnLoad.bind(this);\n  this._boundXdrOnTimeout = this._xdrOnTimeout.bind(this);\n  /**\n   * Emitted when the resource beings to load.\n   *\n   * @event start\n   * @memberof Resource#\n   */\n\n  /**\n   * Emitted each time progress of this resource load updates.\n   * Not all resources types and loader systems can support this event\n   * so sometimes it may not be available. If the resource\n   * is being loaded on a modern browser, using XHR, and the remote server\n   * properly sets Content-Length headers, then this will be available.\n   *\n   * @event progress\n   * @memberof Resource#\n   */\n\n  /**\n   * Emitted once this resource has loaded, if there was an error it will\n   * be in the `error` property.\n   *\n   * @event complete\n   * @memberof Resource#\n   */\n}\n\nResource.prototype = Object.create(EventEmitter.prototype);\nResource.prototype.constructor = Resource;\nmodule.exports = Resource;\n/**\n * Marks the resource as complete.\n *\n * @fires complete\n */\n\nResource.prototype.complete = function () {\n  // TODO: Clean this up in a wrapper or something...gross....\n  if (this.data && this.data.removeEventListener) {\n    this.data.removeEventListener('error', this._boundOnError, false);\n    this.data.removeEventListener('load', this._boundComplete, false);\n    this.data.removeEventListener('progress', this._boundOnProgress, false);\n    this.data.removeEventListener('canplaythrough', this._boundComplete, false);\n  }\n\n  if (this.xhr) {\n    if (this.xhr.removeEventListener) {\n      this.xhr.removeEventListener('error', this._boundXhrOnError, false);\n      this.xhr.removeEventListener('abort', this._boundXhrOnAbort, false);\n      this.xhr.removeEventListener('progress', this._boundOnProgress, false);\n      this.xhr.removeEventListener('load', this._boundXhrOnLoad, false);\n    } else {\n      this.xhr.onerror = null;\n      this.xhr.ontimeout = null;\n      this.xhr.onprogress = null;\n      this.xhr.onload = null;\n    }\n  }\n\n  if (this.isComplete) {\n    throw new Error('Complete called again for an already completed resource.');\n  }\n\n  this.isComplete = true;\n  this.isLoading = false;\n  this.emit('complete', this);\n};\n/**\n * Aborts the loading of this resource, with an optional message.\n *\n * @param {string} message - The message to use for the error\n */\n\n\nResource.prototype.abort = function (message) {\n  // abort can be called multiple times, ignore subsequent calls.\n  if (this.error) {\n    return;\n  } // store error\n\n\n  this.error = new Error(message); // abort the actual loading\n\n  if (this.xhr) {\n    this.xhr.abort();\n  } else if (this.xdr) {\n    this.xdr.abort();\n  } else if (this.data) {\n    // single source\n    if (typeof this.data.src !== 'undefined') {\n      this.data.src = '';\n    } // multi-source\n    else {\n      while (this.data.firstChild) {\n        this.data.removeChild(this.data.firstChild);\n      }\n    }\n  } // done now.\n\n\n  this.complete();\n};\n/**\n * Kicks off loading of this resource. This method is asynchronous.\n *\n * @fires start\n * @param {function} [cb] - Optional callback to call once the resource is loaded.\n */\n\n\nResource.prototype.load = function (cb) {\n  if (this.isLoading) {\n    return;\n  }\n\n  if (this.isComplete) {\n    if (cb) {\n      var self = this;\n      setTimeout(function () {\n        cb(self);\n      }, 1);\n    }\n\n    return;\n  } else if (cb) {\n    this.once('complete', cb);\n  }\n\n  this.isLoading = true;\n  this.emit('start', this); // if unset, determine the value\n\n  if (this.crossOrigin === false || typeof this.crossOrigin !== 'string') {\n    this.crossOrigin = this._determineCrossOrigin(this.url);\n  }\n\n  switch (this.loadType) {\n    case Resource.LOAD_TYPE.IMAGE:\n      this._loadElement('image');\n\n      break;\n\n    case Resource.LOAD_TYPE.AUDIO:\n      this._loadSourceElement('audio');\n\n      break;\n\n    case Resource.LOAD_TYPE.VIDEO:\n      this._loadSourceElement('video');\n\n      break;\n\n    case Resource.LOAD_TYPE.XHR:\n    /* falls through */\n\n    default:\n      if (useXdr && this.crossOrigin) {\n        this._loadXdr();\n      } else {\n        this._loadXhr();\n      }\n\n      break;\n  }\n};\n/**\n * Loads this resources using an element that has a single source,\n * like an HTMLImageElement.\n *\n * @private\n * @param {string} type - The type of element to use.\n */\n\n\nResource.prototype._loadElement = function (type) {\n  if (this.metadata.loadElement) {\n    this.data = this.metadata.loadElement;\n  } else if (type === 'image' && typeof window.Image !== 'undefined') {\n    this.data = new Image();\n  } else {\n    this.data = document.createElement(type);\n  }\n\n  if (this.crossOrigin) {\n    this.data.crossOrigin = this.crossOrigin;\n  }\n\n  if (!this.metadata.skipSource) {\n    this.data.src = this.url;\n  }\n\n  var typeName = 'is' + type[0].toUpperCase() + type.substring(1);\n\n  if (this[typeName] === false) {\n    this[typeName] = true;\n  }\n\n  this.data.addEventListener('error', this._boundOnError, false);\n  this.data.addEventListener('load', this._boundComplete, false);\n  this.data.addEventListener('progress', this._boundOnProgress, false);\n};\n/**\n * Loads this resources using an element that has multiple sources,\n * like an HTMLAudioElement or HTMLVideoElement.\n *\n * @private\n * @param {string} type - The type of element to use.\n */\n\n\nResource.prototype._loadSourceElement = function (type) {\n  if (this.metadata.loadElement) {\n    this.data = this.metadata.loadElement;\n  } else if (type === 'audio' && typeof window.Audio !== 'undefined') {\n    this.data = new Audio();\n  } else {\n    this.data = document.createElement(type);\n  }\n\n  if (this.data === null) {\n    this.abort('Unsupported element ' + type);\n    return;\n  }\n\n  if (!this.metadata.skipSource) {\n    // support for CocoonJS Canvas+ runtime, lacks document.createElement('source')\n    if (navigator.isCocoonJS) {\n      this.data.src = Array.isArray(this.url) ? this.url[0] : this.url;\n    } else if (Array.isArray(this.url)) {\n      for (var i = 0; i < this.url.length; ++i) {\n        this.data.appendChild(this._createSource(type, this.url[i]));\n      }\n    } else {\n      this.data.appendChild(this._createSource(type, this.url));\n    }\n  }\n\n  this['is' + type[0].toUpperCase() + type.substring(1)] = true;\n  this.data.addEventListener('error', this._boundOnError, false);\n  this.data.addEventListener('load', this._boundComplete, false);\n  this.data.addEventListener('progress', this._boundOnProgress, false);\n  this.data.addEventListener('canplaythrough', this._boundComplete, false);\n  this.data.load();\n};\n/**\n * Loads this resources using an XMLHttpRequest.\n *\n * @private\n */\n\n\nResource.prototype._loadXhr = function () {\n  // if unset, determine the value\n  if (typeof this.xhrType !== 'string') {\n    this.xhrType = this._determineXhrType();\n  }\n\n  var xhr = this.xhr = new XMLHttpRequest(); // set the request type and url\n\n  xhr.open('GET', this.url, true); // load json as text and parse it ourselves. We do this because some browsers\n  // *cough* safari *cough* can't deal with it.\n\n  if (this.xhrType === Resource.XHR_RESPONSE_TYPE.JSON || this.xhrType === Resource.XHR_RESPONSE_TYPE.DOCUMENT) {\n    xhr.responseType = Resource.XHR_RESPONSE_TYPE.TEXT;\n  } else {\n    xhr.responseType = this.xhrType;\n  }\n\n  xhr.addEventListener('error', this._boundXhrOnError, false);\n  xhr.addEventListener('abort', this._boundXhrOnAbort, false);\n  xhr.addEventListener('progress', this._boundOnProgress, false);\n  xhr.addEventListener('load', this._boundXhrOnLoad, false);\n  xhr.send();\n};\n/**\n * Loads this resources using an XDomainRequest. This is here because we need to support IE9 (gross).\n *\n * @private\n */\n\n\nResource.prototype._loadXdr = function () {\n  // if unset, determine the value\n  if (typeof this.xhrType !== 'string') {\n    this.xhrType = this._determineXhrType();\n  }\n\n  var xdr = this.xhr = new XDomainRequest(); // XDomainRequest has a few quirks. Occasionally it will abort requests\n  // A way to avoid this is to make sure ALL callbacks are set even if not used\n  // More info here: http://stackoverflow.com/questions/15786966/xdomainrequest-aborts-post-on-ie-9\n\n  xdr.timeout = 5000;\n  xdr.onerror = this._boundXhrOnError;\n  xdr.ontimeout = this._boundXdrOnTimeout;\n  xdr.onprogress = this._boundOnProgress;\n  xdr.onload = this._boundXhrOnLoad;\n  xdr.open('GET', this.url, true); // Note: The xdr.send() call is wrapped in a timeout to prevent an\n  // issue with the interface where some requests are lost if multiple\n  // XDomainRequests are being sent at the same time.\n  // Some info here: https://github.com/photonstorm/phaser/issues/1248\n\n  setTimeout(function () {\n    xdr.send();\n  }, 0);\n};\n/**\n * Creates a source used in loading via an element.\n *\n * @private\n * @param {string} type - The element type (video or audio).\n * @param {string} url - The source URL to load from.\n * @param {string} [mime] - The mime type of the video\n * @return {HTMLSourceElement} The source element.\n */\n\n\nResource.prototype._createSource = function (type, url, mime) {\n  if (!mime) {\n    mime = type + '/' + url.substr(url.lastIndexOf('.') + 1);\n  }\n\n  var source = document.createElement('source');\n  source.src = url;\n  source.type = mime;\n  return source;\n};\n/**\n * Called if a load errors out.\n *\n * @param {Event} event - The error event from the element that emits it.\n * @private\n */\n\n\nResource.prototype._onError = function (event) {\n  this.abort('Failed to load element using ' + event.target.nodeName);\n};\n/**\n * Called if a load progress event fires for xhr/xdr.\n *\n * @fires progress\n * @private\n * @param {XMLHttpRequestProgressEvent|Event} event - Progress event.\n */\n\n\nResource.prototype._onProgress = function (event) {\n  if (event && event.lengthComputable) {\n    this.emit('progress', this, event.loaded / event.total);\n  }\n};\n/**\n * Called if an error event fires for xhr/xdr.\n *\n * @private\n * @param {XMLHttpRequestErrorEvent|Event} event - Error event.\n */\n\n\nResource.prototype._xhrOnError = function () {\n  var xhr = this.xhr;\n  this.abort(reqType(xhr) + ' Request failed. Status: ' + xhr.status + ', text: \"' + xhr.statusText + '\"');\n};\n/**\n * Called if an abort event fires for xhr.\n *\n * @private\n * @param {XMLHttpRequestAbortEvent} event - Abort Event\n */\n\n\nResource.prototype._xhrOnAbort = function () {\n  this.abort(reqType(this.xhr) + ' Request was aborted by the user.');\n};\n/**\n * Called if a timeout event fires for xdr.\n *\n * @private\n * @param {Event} event - Timeout event.\n */\n\n\nResource.prototype._xdrOnTimeout = function () {\n  this.abort(reqType(this.xhr) + ' Request timed out.');\n};\n/**\n * Called when data successfully loads from an xhr/xdr request.\n *\n * @private\n * @param {XMLHttpRequestLoadEvent|Event} event - Load event\n */\n\n\nResource.prototype._xhrOnLoad = function () {\n  var xhr = this.xhr;\n  var status = typeof xhr.status === 'undefined' ? xhr.status : STATUS_OK; // XDR has no `.status`, assume 200.\n  // status can be 0 when using the file:// protocol, also check if a response was found\n\n  if (status === STATUS_OK || status === STATUS_EMPTY || status === STATUS_NONE && xhr.responseText.length > 0) {\n    // if text, just return it\n    if (this.xhrType === Resource.XHR_RESPONSE_TYPE.TEXT) {\n      this.data = xhr.responseText;\n    } // if json, parse into json object\n    else if (this.xhrType === Resource.XHR_RESPONSE_TYPE.JSON) {\n      try {\n        this.data = JSON.parse(xhr.responseText);\n        this.isJson = true;\n      } catch (e) {\n        this.abort('Error trying to parse loaded json:', e);\n        return;\n      }\n    } // if xml, parse into an xml document or div element\n    else if (this.xhrType === Resource.XHR_RESPONSE_TYPE.DOCUMENT) {\n      try {\n        if (window.DOMParser) {\n          var domparser = new DOMParser();\n          this.data = domparser.parseFromString(xhr.responseText, 'text/xml');\n        } else {\n          var div = document.createElement('div');\n          div.innerHTML = xhr.responseText;\n          this.data = div;\n        }\n\n        this.isXml = true;\n      } catch (e) {\n        this.abort('Error trying to parse loaded xml:', e);\n        return;\n      }\n    } // other types just return the response\n    else {\n      this.data = xhr.response || xhr.responseText;\n    }\n  } else {\n    this.abort('[' + xhr.status + ']' + xhr.statusText + ':' + xhr.responseURL);\n    return;\n  }\n\n  this.complete();\n};\n/**\n * Sets the `crossOrigin` property for this resource based on if the url\n * for this resource is cross-origin. If crossOrigin was manually set, this\n * function does nothing.\n *\n * @private\n * @param {string} url - The url to test.\n * @param {object} [loc=window.location] - The location object to test against.\n * @return {string} The crossOrigin value to use (or empty string for none).\n */\n\n\nResource.prototype._determineCrossOrigin = function (url, loc) {\n  // data: and javascript: urls are considered same-origin\n  if (url.indexOf('data:') === 0) {\n    return '';\n  } // default is window.location\n\n\n  loc = loc || window.location;\n\n  if (!tempAnchor) {\n    tempAnchor = document.createElement('a');\n  } // let the browser determine the full href for the url of this resource and then\n  // parse with the node url lib, we can't use the properties of the anchor element\n  // because they don't work in IE9 :(\n\n\n  tempAnchor.href = url;\n  url = parseUri(tempAnchor.href, {\n    strictMode: true\n  });\n  var samePort = !url.port && loc.port === '' || url.port === loc.port;\n  var protocol = url.protocol ? url.protocol + ':' : ''; // if cross origin\n\n  if (url.host !== loc.hostname || !samePort || protocol !== loc.protocol) {\n    return 'anonymous';\n  }\n\n  return '';\n};\n/**\n * Determines the responseType of an XHR request based on the extension of the\n * resource being loaded.\n *\n * @private\n * @return {Resource.XHR_RESPONSE_TYPE} The responseType to use.\n */\n\n\nResource.prototype._determineXhrType = function () {\n  return Resource._xhrTypeMap[this._getExtension()] || Resource.XHR_RESPONSE_TYPE.TEXT;\n};\n\nResource.prototype._determineLoadType = function () {\n  return Resource._loadTypeMap[this._getExtension()] || Resource.LOAD_TYPE.XHR;\n};\n\nResource.prototype._getExtension = function () {\n  var url = this.url;\n  var ext = '';\n\n  if (this.isDataUrl) {\n    var slashIndex = url.indexOf('/');\n    ext = url.substring(slashIndex + 1, url.indexOf(';', slashIndex));\n  } else {\n    var queryStart = url.indexOf('?');\n\n    if (queryStart !== -1) {\n      url = url.substring(0, queryStart);\n    }\n\n    ext = url.substring(url.lastIndexOf('.') + 1);\n  }\n\n  return ext.toLowerCase();\n};\n/**\n * Determines the mime type of an XHR request based on the responseType of\n * resource being loaded.\n *\n * @private\n * @param {Resource.XHR_RESPONSE_TYPE} type - The type to get a mime type for.\n * @return {string} The mime type to use.\n */\n\n\nResource.prototype._getMimeFromXhrType = function (type) {\n  switch (type) {\n    case Resource.XHR_RESPONSE_TYPE.BUFFER:\n      return 'application/octet-binary';\n\n    case Resource.XHR_RESPONSE_TYPE.BLOB:\n      return 'application/blob';\n\n    case Resource.XHR_RESPONSE_TYPE.DOCUMENT:\n      return 'application/xml';\n\n    case Resource.XHR_RESPONSE_TYPE.JSON:\n      return 'application/json';\n\n    case Resource.XHR_RESPONSE_TYPE.DEFAULT:\n    case Resource.XHR_RESPONSE_TYPE.TEXT:\n    /* falls through */\n\n    default:\n      return 'text/plain';\n  }\n};\n/**\n * Quick helper to get string xhr type.\n *\n * @ignore\n * @param {XMLHttpRequest|XDomainRequest} xhr - The request to check.\n * @return {string} The type.\n */\n\n\nfunction reqType(xhr) {\n  return xhr.toString().replace('object ', '');\n}\n/**\n * The types of loading a resource can use.\n *\n * @static\n * @readonly\n * @enum {number}\n */\n\n\nResource.LOAD_TYPE = {\n  /** Uses XMLHttpRequest to load the resource. */\n  XHR: 1,\n\n  /** Uses an `Image` object to load the resource. */\n  IMAGE: 2,\n\n  /** Uses an `Audio` object to load the resource. */\n  AUDIO: 3,\n\n  /** Uses a `Video` object to load the resource. */\n  VIDEO: 4\n};\n/**\n * The XHR ready states, used internally.\n *\n * @static\n * @readonly\n * @enum {string}\n */\n\nResource.XHR_RESPONSE_TYPE = {\n  /** defaults to text */\n  DEFAULT: 'text',\n\n  /** ArrayBuffer */\n  BUFFER: 'arraybuffer',\n\n  /** Blob */\n  BLOB: 'blob',\n\n  /** Document */\n  DOCUMENT: 'document',\n\n  /** Object */\n  JSON: 'json',\n\n  /** String */\n  TEXT: 'text'\n};\nResource._loadTypeMap = {\n  gif: Resource.LOAD_TYPE.IMAGE,\n  png: Resource.LOAD_TYPE.IMAGE,\n  bmp: Resource.LOAD_TYPE.IMAGE,\n  jpg: Resource.LOAD_TYPE.IMAGE,\n  jpeg: Resource.LOAD_TYPE.IMAGE,\n  tif: Resource.LOAD_TYPE.IMAGE,\n  tiff: Resource.LOAD_TYPE.IMAGE,\n  webp: Resource.LOAD_TYPE.IMAGE,\n  tga: Resource.LOAD_TYPE.IMAGE,\n  'svg+xml': Resource.LOAD_TYPE.IMAGE\n};\nResource._xhrTypeMap = {\n  // xml\n  xhtml: Resource.XHR_RESPONSE_TYPE.DOCUMENT,\n  html: Resource.XHR_RESPONSE_TYPE.DOCUMENT,\n  htm: Resource.XHR_RESPONSE_TYPE.DOCUMENT,\n  xml: Resource.XHR_RESPONSE_TYPE.DOCUMENT,\n  tmx: Resource.XHR_RESPONSE_TYPE.DOCUMENT,\n  tsx: Resource.XHR_RESPONSE_TYPE.DOCUMENT,\n  svg: Resource.XHR_RESPONSE_TYPE.DOCUMENT,\n  // images\n  gif: Resource.XHR_RESPONSE_TYPE.BLOB,\n  png: Resource.XHR_RESPONSE_TYPE.BLOB,\n  bmp: Resource.XHR_RESPONSE_TYPE.BLOB,\n  jpg: Resource.XHR_RESPONSE_TYPE.BLOB,\n  jpeg: Resource.XHR_RESPONSE_TYPE.BLOB,\n  tif: Resource.XHR_RESPONSE_TYPE.BLOB,\n  tiff: Resource.XHR_RESPONSE_TYPE.BLOB,\n  webp: Resource.XHR_RESPONSE_TYPE.BLOB,\n  tga: Resource.XHR_RESPONSE_TYPE.BLOB,\n  // json\n  json: Resource.XHR_RESPONSE_TYPE.JSON,\n  // text\n  text: Resource.XHR_RESPONSE_TYPE.TEXT,\n  txt: Resource.XHR_RESPONSE_TYPE.TEXT\n};\n/**\n * Sets the load type to be used for a specific extension.\n *\n * @static\n * @param {string} extname - The extension to set the type for, e.g. \"png\" or \"fnt\"\n * @param {Resource.LOAD_TYPE} loadType - The load type to set it to.\n */\n\nResource.setExtensionLoadType = function (extname, loadType) {\n  setExtMap(Resource._loadTypeMap, extname, loadType);\n};\n/**\n * Sets the load type to be used for a specific extension.\n *\n * @static\n * @param {string} extname - The extension to set the type for, e.g. \"png\" or \"fnt\"\n * @param {Resource.XHR_RESPONSE_TYPE} xhrType - The xhr type to set it to.\n */\n\n\nResource.setExtensionXhrType = function (extname, xhrType) {\n  setExtMap(Resource._xhrTypeMap, extname, xhrType);\n};\n\nfunction setExtMap(map, extname, val) {\n  if (extname && extname.indexOf('.') === 0) {\n    extname = extname.substring(1);\n  }\n\n  if (!extname) {\n    return;\n  }\n\n  map[extname] = val;\n}","map":{"version":3,"names":["EventEmitter","require","parseUri","useXdr","window","XDomainRequest","XMLHttpRequest","tempAnchor","STATUS_NONE","STATUS_OK","STATUS_EMPTY","Resource","name","url","options","call","Error","isDataUrl","indexOf","data","crossOrigin","loadType","_determineLoadType","xhrType","metadata","error","xhr","isJson","isXml","isImage","isAudio","isVideo","isComplete","isLoading","_dequeue","_boundComplete","complete","bind","_boundOnError","_onError","_boundOnProgress","_onProgress","_boundXhrOnError","_xhrOnError","_boundXhrOnAbort","_xhrOnAbort","_boundXhrOnLoad","_xhrOnLoad","_boundXdrOnTimeout","_xdrOnTimeout","prototype","Object","create","constructor","module","exports","removeEventListener","onerror","ontimeout","onprogress","onload","emit","abort","message","xdr","src","firstChild","removeChild","load","cb","self","setTimeout","once","_determineCrossOrigin","LOAD_TYPE","IMAGE","_loadElement","AUDIO","_loadSourceElement","VIDEO","XHR","_loadXdr","_loadXhr","type","loadElement","Image","document","createElement","skipSource","typeName","toUpperCase","substring","addEventListener","Audio","navigator","isCocoonJS","Array","isArray","i","length","appendChild","_createSource","_determineXhrType","open","XHR_RESPONSE_TYPE","JSON","DOCUMENT","responseType","TEXT","send","timeout","mime","substr","lastIndexOf","source","event","target","nodeName","lengthComputable","loaded","total","reqType","status","statusText","responseText","parse","e","DOMParser","domparser","parseFromString","div","innerHTML","response","responseURL","loc","location","href","strictMode","samePort","port","protocol","host","hostname","_xhrTypeMap","_getExtension","_loadTypeMap","ext","slashIndex","queryStart","toLowerCase","_getMimeFromXhrType","BUFFER","BLOB","DEFAULT","toString","replace","gif","png","bmp","jpg","jpeg","tif","tiff","webp","tga","xhtml","html","htm","xml","tmx","tsx","svg","json","text","txt","setExtensionLoadType","extname","setExtMap","setExtensionXhrType","map","val"],"sources":["/home/reyden-martin/Documents/Tech2/HUB/Sony CSL/SONY-CSL-PROJECT/node_modules/resource-loader/src/Resource.js"],"sourcesContent":["'use strict';\n\nvar EventEmitter    = require('eventemitter3');\nvar parseUri        = require('parse-uri');\n\n// tests is CORS is supported in XHR, if not we need to use XDR\nvar useXdr = !!(window.XDomainRequest && !('withCredentials' in (new XMLHttpRequest())));\nvar tempAnchor = null;\n\n// some status constants\nvar STATUS_NONE = 0;\nvar STATUS_OK = 200;\nvar STATUS_EMPTY = 204;\n\n/**\n * Manages the state and loading of a single resource represented by\n * a single URL.\n *\n * @class\n * @param {string} name - The name of the resource to load.\n * @param {string|string[]} url - The url for this resource, for audio/video loads you can pass an array of sources.\n * @param {object} [options] - The options for the load.\n * @param {string|boolean} [options.crossOrigin] - Is this request cross-origin? Default is to determine automatically.\n * @param {Resource.LOAD_TYPE} [options.loadType=Resource.LOAD_TYPE.XHR] - How should this resource be loaded?\n * @param {Resource.XHR_RESPONSE_TYPE} [options.xhrType=Resource.XHR_RESPONSE_TYPE.DEFAULT] - How should the data being\n *      loaded be interpreted when using XHR?\n * @param {object} [options.metadata] - Extra info for middleware.\n */\nfunction Resource(name, url, options) {\n    EventEmitter.call(this);\n\n    options = options || {};\n\n    if (typeof name !== 'string' || typeof url !== 'string') {\n        throw new Error('Both name and url are required for constructing a resource.');\n    }\n\n    /**\n     * The name of this resource.\n     *\n     * @member {string}\n     * @readonly\n     */\n    this.name = name;\n\n    /**\n     * The url used to load this resource.\n     *\n     * @member {string}\n     * @readonly\n     */\n    this.url = url;\n\n    /**\n     * Stores whether or not this url is a data url.\n     *\n     * @member {boolean}\n     * @readonly\n     */\n    this.isDataUrl = this.url.indexOf('data:') === 0;\n\n    /**\n     * The data that was loaded by the resource.\n     *\n     * @member {any}\n     */\n    this.data = null;\n\n    /**\n     * Is this request cross-origin? If unset, determined automatically.\n     *\n     * @member {string}\n     */\n    this.crossOrigin = options.crossOrigin === true ? 'anonymous' : options.crossOrigin;\n\n    /**\n     * The method of loading to use for this resource.\n     *\n     * @member {Resource.LOAD_TYPE}\n     */\n    this.loadType = options.loadType || this._determineLoadType();\n\n    /**\n     * The type used to load the resource via XHR. If unset, determined automatically.\n     *\n     * @member {string}\n     */\n    this.xhrType = options.xhrType;\n\n    /**\n     * Extra info for middleware, and controlling specifics about how the resource loads.\n     *\n     * Note that if you pass in a `loadElement`, the Resource class takes ownership of it.\n     * Meaning it will modify it as it sees fit.\n     *\n     * @member {object}\n     * @property {HTMLImageElement|HTMLAudioElement|HTMLVideoElement} [loadElement=null] - The\n     *  element to use for loading, instead of creating one.\n     * @property {boolean} [skipSource=false] - Skips adding source(s) to the load element. This\n     *  is useful if you want to pass in a `loadElement` that you already added load sources\n     *  to.\n     */\n    this.metadata = options.metadata || {};\n\n    /**\n     * The error that occurred while loading (if any).\n     *\n     * @member {Error}\n     * @readonly\n     */\n    this.error = null;\n\n    /**\n     * The XHR object that was used to load this resource. This is only set\n     * when `loadType` is `Resource.LOAD_TYPE.XHR`.\n     *\n     * @member {XMLHttpRequest}\n     */\n    this.xhr = null;\n\n    /**\n     * Describes if this resource was loaded as json. Only valid after the resource\n     * has completely loaded.\n     *\n     * @member {boolean}\n     */\n    this.isJson = false;\n\n    /**\n     * Describes if this resource was loaded as xml. Only valid after the resource\n     * has completely loaded.\n     *\n     * @member {boolean}\n     */\n    this.isXml = false;\n\n    /**\n     * Describes if this resource was loaded as an image tag. Only valid after the resource\n     * has completely loaded.\n     *\n     * @member {boolean}\n     */\n    this.isImage = false;\n\n    /**\n     * Describes if this resource was loaded as an audio tag. Only valid after the resource\n     * has completely loaded.\n     *\n     * @member {boolean}\n     */\n    this.isAudio = false;\n\n    /**\n     * Describes if this resource was loaded as a video tag. Only valid after the resource\n     * has completely loaded.\n     *\n     * @member {boolean}\n     */\n    this.isVideo = false;\n\n    /**\n     * Describes if this resource has finished loading. Is true when the resource has completely\n     * loaded.\n     *\n     * @member {boolean}\n     */\n    this.isComplete = false;\n\n    /**\n     * Describes if this resource is currently loading. Is true when the resource starts loading,\n     * and is false again when complete.\n     *\n     * @member {boolean}\n     */\n    this.isLoading = false;\n\n    /**\n     * The `dequeue` method that will be used a storage place for the async queue dequeue method\n     * used privately by the loader.\n     *\n     * @private\n     * @member {function}\n     */\n    this._dequeue = null;\n\n    /**\n     * The `complete` function bound to this resource's context.\n     *\n     * @private\n     * @member {function}\n     */\n    this._boundComplete = this.complete.bind(this);\n\n    /**\n     * The `_onError` function bound to this resource's context.\n     *\n     * @private\n     * @member {function}\n     */\n    this._boundOnError = this._onError.bind(this);\n\n    /**\n     * The `_onProgress` function bound to this resource's context.\n     *\n     * @private\n     * @member {function}\n     */\n    this._boundOnProgress = this._onProgress.bind(this);\n\n    // xhr callbacks\n    this._boundXhrOnError = this._xhrOnError.bind(this);\n    this._boundXhrOnAbort = this._xhrOnAbort.bind(this);\n    this._boundXhrOnLoad = this._xhrOnLoad.bind(this);\n    this._boundXdrOnTimeout = this._xdrOnTimeout.bind(this);\n\n    /**\n     * Emitted when the resource beings to load.\n     *\n     * @event start\n     * @memberof Resource#\n     */\n\n    /**\n     * Emitted each time progress of this resource load updates.\n     * Not all resources types and loader systems can support this event\n     * so sometimes it may not be available. If the resource\n     * is being loaded on a modern browser, using XHR, and the remote server\n     * properly sets Content-Length headers, then this will be available.\n     *\n     * @event progress\n     * @memberof Resource#\n     */\n\n    /**\n     * Emitted once this resource has loaded, if there was an error it will\n     * be in the `error` property.\n     *\n     * @event complete\n     * @memberof Resource#\n     */\n}\n\nResource.prototype = Object.create(EventEmitter.prototype);\nResource.prototype.constructor = Resource;\nmodule.exports = Resource;\n\n/**\n * Marks the resource as complete.\n *\n * @fires complete\n */\nResource.prototype.complete = function () {\n    // TODO: Clean this up in a wrapper or something...gross....\n    if (this.data && this.data.removeEventListener) {\n        this.data.removeEventListener('error', this._boundOnError, false);\n        this.data.removeEventListener('load', this._boundComplete, false);\n        this.data.removeEventListener('progress', this._boundOnProgress, false);\n        this.data.removeEventListener('canplaythrough', this._boundComplete, false);\n    }\n\n    if (this.xhr) {\n        if (this.xhr.removeEventListener) {\n            this.xhr.removeEventListener('error', this._boundXhrOnError, false);\n            this.xhr.removeEventListener('abort', this._boundXhrOnAbort, false);\n            this.xhr.removeEventListener('progress', this._boundOnProgress, false);\n            this.xhr.removeEventListener('load', this._boundXhrOnLoad, false);\n        }\n        else {\n            this.xhr.onerror = null;\n            this.xhr.ontimeout = null;\n            this.xhr.onprogress = null;\n            this.xhr.onload = null;\n        }\n    }\n\n    if (this.isComplete) {\n        throw new Error('Complete called again for an already completed resource.');\n    }\n\n    this.isComplete = true;\n    this.isLoading = false;\n\n    this.emit('complete', this);\n};\n\n/**\n * Aborts the loading of this resource, with an optional message.\n *\n * @param {string} message - The message to use for the error\n */\nResource.prototype.abort = function (message) {\n    // abort can be called multiple times, ignore subsequent calls.\n    if (this.error) {\n        return;\n    }\n\n    // store error\n    this.error = new Error(message);\n\n    // abort the actual loading\n    if (this.xhr) {\n        this.xhr.abort();\n    }\n    else if (this.xdr) {\n        this.xdr.abort();\n    }\n    else if (this.data) {\n        // single source\n        if (typeof this.data.src !== 'undefined') {\n            this.data.src = '';\n        }\n        // multi-source\n        else {\n            while (this.data.firstChild) {\n                this.data.removeChild(this.data.firstChild);\n            }\n        }\n    }\n\n    // done now.\n    this.complete();\n};\n\n/**\n * Kicks off loading of this resource. This method is asynchronous.\n *\n * @fires start\n * @param {function} [cb] - Optional callback to call once the resource is loaded.\n */\nResource.prototype.load = function (cb) {\n    if (this.isLoading) {\n        return;\n    }\n\n    if (this.isComplete) {\n        if (cb) {\n            var self = this;\n\n            setTimeout(function () {\n                cb(self);\n            }, 1);\n        }\n\n        return;\n    }\n    else if (cb) {\n        this.once('complete', cb);\n    }\n\n    this.isLoading = true;\n\n    this.emit('start', this);\n\n    // if unset, determine the value\n    if (this.crossOrigin === false || typeof this.crossOrigin !== 'string') {\n        this.crossOrigin = this._determineCrossOrigin(this.url);\n    }\n\n    switch (this.loadType) {\n        case Resource.LOAD_TYPE.IMAGE:\n            this._loadElement('image');\n            break;\n\n        case Resource.LOAD_TYPE.AUDIO:\n            this._loadSourceElement('audio');\n            break;\n\n        case Resource.LOAD_TYPE.VIDEO:\n            this._loadSourceElement('video');\n            break;\n\n        case Resource.LOAD_TYPE.XHR:\n            /* falls through */\n        default:\n            if (useXdr && this.crossOrigin) {\n                this._loadXdr();\n            }\n            else {\n                this._loadXhr();\n            }\n            break;\n    }\n};\n\n/**\n * Loads this resources using an element that has a single source,\n * like an HTMLImageElement.\n *\n * @private\n * @param {string} type - The type of element to use.\n */\nResource.prototype._loadElement = function (type) {\n    if (this.metadata.loadElement) {\n        this.data = this.metadata.loadElement;\n    }\n    else if (type === 'image' && typeof window.Image !== 'undefined') {\n        this.data = new Image();\n    }\n    else {\n        this.data = document.createElement(type);\n    }\n\n    if (this.crossOrigin) {\n        this.data.crossOrigin = this.crossOrigin;\n    }\n\n    if (!this.metadata.skipSource) {\n        this.data.src = this.url;\n    }\n\n    var typeName = 'is' + type[0].toUpperCase() + type.substring(1);\n\n    if (this[typeName] === false) {\n        this[typeName] = true;\n    }\n\n    this.data.addEventListener('error', this._boundOnError, false);\n    this.data.addEventListener('load', this._boundComplete, false);\n    this.data.addEventListener('progress', this._boundOnProgress, false);\n};\n\n/**\n * Loads this resources using an element that has multiple sources,\n * like an HTMLAudioElement or HTMLVideoElement.\n *\n * @private\n * @param {string} type - The type of element to use.\n */\nResource.prototype._loadSourceElement = function (type) {\n    if (this.metadata.loadElement) {\n        this.data = this.metadata.loadElement;\n    }\n    else if (type === 'audio' && typeof window.Audio !== 'undefined') {\n        this.data = new Audio();\n    }\n    else {\n        this.data = document.createElement(type);\n    }\n\n    if (this.data === null) {\n        this.abort('Unsupported element ' + type);\n\n        return;\n    }\n\n    if (!this.metadata.skipSource) {\n        // support for CocoonJS Canvas+ runtime, lacks document.createElement('source')\n        if (navigator.isCocoonJS) {\n            this.data.src = Array.isArray(this.url) ? this.url[0] : this.url;\n        }\n        else if (Array.isArray(this.url)) {\n            for (var i = 0; i < this.url.length; ++i) {\n                this.data.appendChild(this._createSource(type, this.url[i]));\n            }\n        }\n        else {\n            this.data.appendChild(this._createSource(type, this.url));\n        }\n    }\n\n    this['is' + type[0].toUpperCase() + type.substring(1)] = true;\n\n    this.data.addEventListener('error', this._boundOnError, false);\n    this.data.addEventListener('load', this._boundComplete, false);\n    this.data.addEventListener('progress', this._boundOnProgress, false);\n    this.data.addEventListener('canplaythrough', this._boundComplete, false);\n\n    this.data.load();\n};\n\n/**\n * Loads this resources using an XMLHttpRequest.\n *\n * @private\n */\nResource.prototype._loadXhr = function () {\n    // if unset, determine the value\n    if (typeof this.xhrType !== 'string') {\n        this.xhrType = this._determineXhrType();\n    }\n\n    var xhr = this.xhr = new XMLHttpRequest();\n\n    // set the request type and url\n    xhr.open('GET', this.url, true);\n\n    // load json as text and parse it ourselves. We do this because some browsers\n    // *cough* safari *cough* can't deal with it.\n    if (this.xhrType === Resource.XHR_RESPONSE_TYPE.JSON || this.xhrType === Resource.XHR_RESPONSE_TYPE.DOCUMENT) {\n        xhr.responseType = Resource.XHR_RESPONSE_TYPE.TEXT;\n    }\n    else {\n        xhr.responseType = this.xhrType;\n    }\n\n    xhr.addEventListener('error', this._boundXhrOnError, false);\n    xhr.addEventListener('abort', this._boundXhrOnAbort, false);\n    xhr.addEventListener('progress', this._boundOnProgress, false);\n    xhr.addEventListener('load', this._boundXhrOnLoad, false);\n\n    xhr.send();\n};\n\n/**\n * Loads this resources using an XDomainRequest. This is here because we need to support IE9 (gross).\n *\n * @private\n */\nResource.prototype._loadXdr = function () {\n    // if unset, determine the value\n    if (typeof this.xhrType !== 'string') {\n        this.xhrType = this._determineXhrType();\n    }\n\n    var xdr = this.xhr = new XDomainRequest();\n\n    // XDomainRequest has a few quirks. Occasionally it will abort requests\n    // A way to avoid this is to make sure ALL callbacks are set even if not used\n    // More info here: http://stackoverflow.com/questions/15786966/xdomainrequest-aborts-post-on-ie-9\n    xdr.timeout = 5000;\n\n    xdr.onerror = this._boundXhrOnError;\n    xdr.ontimeout = this._boundXdrOnTimeout;\n    xdr.onprogress = this._boundOnProgress;\n    xdr.onload = this._boundXhrOnLoad;\n\n    xdr.open('GET', this.url, true);\n\n    // Note: The xdr.send() call is wrapped in a timeout to prevent an\n    // issue with the interface where some requests are lost if multiple\n    // XDomainRequests are being sent at the same time.\n    // Some info here: https://github.com/photonstorm/phaser/issues/1248\n    setTimeout(function () {\n        xdr.send();\n    }, 0);\n};\n\n/**\n * Creates a source used in loading via an element.\n *\n * @private\n * @param {string} type - The element type (video or audio).\n * @param {string} url - The source URL to load from.\n * @param {string} [mime] - The mime type of the video\n * @return {HTMLSourceElement} The source element.\n */\nResource.prototype._createSource = function (type, url, mime) {\n    if (!mime) {\n        mime = type + '/' + url.substr(url.lastIndexOf('.') + 1);\n    }\n\n    var source = document.createElement('source');\n\n    source.src = url;\n    source.type = mime;\n\n    return source;\n};\n\n/**\n * Called if a load errors out.\n *\n * @param {Event} event - The error event from the element that emits it.\n * @private\n */\nResource.prototype._onError = function (event) {\n    this.abort('Failed to load element using ' + event.target.nodeName);\n};\n\n/**\n * Called if a load progress event fires for xhr/xdr.\n *\n * @fires progress\n * @private\n * @param {XMLHttpRequestProgressEvent|Event} event - Progress event.\n */\nResource.prototype._onProgress = function (event) {\n    if (event && event.lengthComputable) {\n        this.emit('progress', this, event.loaded / event.total);\n    }\n};\n\n/**\n * Called if an error event fires for xhr/xdr.\n *\n * @private\n * @param {XMLHttpRequestErrorEvent|Event} event - Error event.\n */\nResource.prototype._xhrOnError = function () {\n    var xhr = this.xhr;\n\n    this.abort(reqType(xhr) + ' Request failed. Status: ' + xhr.status + ', text: \"' + xhr.statusText + '\"');\n};\n\n/**\n * Called if an abort event fires for xhr.\n *\n * @private\n * @param {XMLHttpRequestAbortEvent} event - Abort Event\n */\nResource.prototype._xhrOnAbort = function () {\n    this.abort(reqType(this.xhr) + ' Request was aborted by the user.');\n};\n\n/**\n * Called if a timeout event fires for xdr.\n *\n * @private\n * @param {Event} event - Timeout event.\n */\nResource.prototype._xdrOnTimeout = function () {\n    this.abort(reqType(this.xhr) + ' Request timed out.');\n};\n\n/**\n * Called when data successfully loads from an xhr/xdr request.\n *\n * @private\n * @param {XMLHttpRequestLoadEvent|Event} event - Load event\n */\nResource.prototype._xhrOnLoad = function () {\n    var xhr = this.xhr;\n    var status = typeof xhr.status === 'undefined' ? xhr.status : STATUS_OK; // XDR has no `.status`, assume 200.\n\n    // status can be 0 when using the file:// protocol, also check if a response was found\n    if (status === STATUS_OK || status === STATUS_EMPTY || (status === STATUS_NONE && xhr.responseText.length > 0)) {\n        // if text, just return it\n        if (this.xhrType === Resource.XHR_RESPONSE_TYPE.TEXT) {\n            this.data = xhr.responseText;\n        }\n        // if json, parse into json object\n        else if (this.xhrType === Resource.XHR_RESPONSE_TYPE.JSON) {\n            try {\n                this.data = JSON.parse(xhr.responseText);\n                this.isJson = true;\n            }\n            catch (e) {\n                this.abort('Error trying to parse loaded json:', e);\n\n                return;\n            }\n        }\n        // if xml, parse into an xml document or div element\n        else if (this.xhrType === Resource.XHR_RESPONSE_TYPE.DOCUMENT) {\n            try {\n                if (window.DOMParser) {\n                    var domparser = new DOMParser();\n\n                    this.data = domparser.parseFromString(xhr.responseText, 'text/xml');\n                }\n                else {\n                    var div = document.createElement('div');\n\n                    div.innerHTML = xhr.responseText;\n                    this.data = div;\n                }\n                this.isXml = true;\n            }\n            catch (e) {\n                this.abort('Error trying to parse loaded xml:', e);\n\n                return;\n            }\n        }\n        // other types just return the response\n        else {\n            this.data = xhr.response || xhr.responseText;\n        }\n    }\n    else {\n        this.abort('[' + xhr.status + ']' + xhr.statusText + ':' + xhr.responseURL);\n\n        return;\n    }\n\n    this.complete();\n};\n\n/**\n * Sets the `crossOrigin` property for this resource based on if the url\n * for this resource is cross-origin. If crossOrigin was manually set, this\n * function does nothing.\n *\n * @private\n * @param {string} url - The url to test.\n * @param {object} [loc=window.location] - The location object to test against.\n * @return {string} The crossOrigin value to use (or empty string for none).\n */\nResource.prototype._determineCrossOrigin = function (url, loc) {\n    // data: and javascript: urls are considered same-origin\n    if (url.indexOf('data:') === 0) {\n        return '';\n    }\n\n    // default is window.location\n    loc = loc || window.location;\n\n    if (!tempAnchor) {\n        tempAnchor = document.createElement('a');\n    }\n\n    // let the browser determine the full href for the url of this resource and then\n    // parse with the node url lib, we can't use the properties of the anchor element\n    // because they don't work in IE9 :(\n    tempAnchor.href = url;\n    url = parseUri(tempAnchor.href, { strictMode: true });\n\n    var samePort = (!url.port && loc.port === '') || (url.port === loc.port);\n    var protocol = url.protocol ? url.protocol + ':' : '';\n\n    // if cross origin\n    if (url.host !== loc.hostname || !samePort || protocol !== loc.protocol) {\n        return 'anonymous';\n    }\n\n    return '';\n};\n\n/**\n * Determines the responseType of an XHR request based on the extension of the\n * resource being loaded.\n *\n * @private\n * @return {Resource.XHR_RESPONSE_TYPE} The responseType to use.\n */\nResource.prototype._determineXhrType = function () {\n    return Resource._xhrTypeMap[this._getExtension()] || Resource.XHR_RESPONSE_TYPE.TEXT;\n};\n\nResource.prototype._determineLoadType = function () {\n    return Resource._loadTypeMap[this._getExtension()] || Resource.LOAD_TYPE.XHR;\n};\n\nResource.prototype._getExtension = function () {\n    var url = this.url;\n    var ext = '';\n\n    if (this.isDataUrl) {\n        var slashIndex = url.indexOf('/');\n\n        ext = url.substring(slashIndex + 1, url.indexOf(';', slashIndex));\n    }\n    else {\n        var queryStart = url.indexOf('?');\n\n        if (queryStart !== -1) {\n            url = url.substring(0, queryStart);\n        }\n\n        ext = url.substring(url.lastIndexOf('.') + 1);\n    }\n\n    return ext.toLowerCase();\n};\n\n/**\n * Determines the mime type of an XHR request based on the responseType of\n * resource being loaded.\n *\n * @private\n * @param {Resource.XHR_RESPONSE_TYPE} type - The type to get a mime type for.\n * @return {string} The mime type to use.\n */\nResource.prototype._getMimeFromXhrType = function (type) {\n    switch (type) {\n        case Resource.XHR_RESPONSE_TYPE.BUFFER:\n            return 'application/octet-binary';\n\n        case Resource.XHR_RESPONSE_TYPE.BLOB:\n            return 'application/blob';\n\n        case Resource.XHR_RESPONSE_TYPE.DOCUMENT:\n            return 'application/xml';\n\n        case Resource.XHR_RESPONSE_TYPE.JSON:\n            return 'application/json';\n\n        case Resource.XHR_RESPONSE_TYPE.DEFAULT:\n        case Resource.XHR_RESPONSE_TYPE.TEXT:\n            /* falls through */\n        default:\n            return 'text/plain';\n\n    }\n};\n\n/**\n * Quick helper to get string xhr type.\n *\n * @ignore\n * @param {XMLHttpRequest|XDomainRequest} xhr - The request to check.\n * @return {string} The type.\n */\nfunction reqType(xhr) {\n    return xhr.toString().replace('object ', '');\n}\n\n/**\n * The types of loading a resource can use.\n *\n * @static\n * @readonly\n * @enum {number}\n */\nResource.LOAD_TYPE = {\n    /** Uses XMLHttpRequest to load the resource. */\n    XHR:    1,\n    /** Uses an `Image` object to load the resource. */\n    IMAGE:  2,\n    /** Uses an `Audio` object to load the resource. */\n    AUDIO:  3,\n    /** Uses a `Video` object to load the resource. */\n    VIDEO:  4\n};\n\n/**\n * The XHR ready states, used internally.\n *\n * @static\n * @readonly\n * @enum {string}\n */\nResource.XHR_RESPONSE_TYPE = {\n    /** defaults to text */\n    DEFAULT:    'text',\n    /** ArrayBuffer */\n    BUFFER:     'arraybuffer',\n    /** Blob */\n    BLOB:       'blob',\n    /** Document */\n    DOCUMENT:   'document',\n    /** Object */\n    JSON:       'json',\n    /** String */\n    TEXT:       'text'\n};\n\nResource._loadTypeMap = {\n    gif:      Resource.LOAD_TYPE.IMAGE,\n    png:      Resource.LOAD_TYPE.IMAGE,\n    bmp:      Resource.LOAD_TYPE.IMAGE,\n    jpg:      Resource.LOAD_TYPE.IMAGE,\n    jpeg:     Resource.LOAD_TYPE.IMAGE,\n    tif:      Resource.LOAD_TYPE.IMAGE,\n    tiff:     Resource.LOAD_TYPE.IMAGE,\n    webp:     Resource.LOAD_TYPE.IMAGE,\n    tga:      Resource.LOAD_TYPE.IMAGE,\n    'svg+xml':  Resource.LOAD_TYPE.IMAGE\n};\n\nResource._xhrTypeMap = {\n    // xml\n    xhtml:    Resource.XHR_RESPONSE_TYPE.DOCUMENT,\n    html:     Resource.XHR_RESPONSE_TYPE.DOCUMENT,\n    htm:      Resource.XHR_RESPONSE_TYPE.DOCUMENT,\n    xml:      Resource.XHR_RESPONSE_TYPE.DOCUMENT,\n    tmx:      Resource.XHR_RESPONSE_TYPE.DOCUMENT,\n    tsx:      Resource.XHR_RESPONSE_TYPE.DOCUMENT,\n    svg:      Resource.XHR_RESPONSE_TYPE.DOCUMENT,\n\n    // images\n    gif:      Resource.XHR_RESPONSE_TYPE.BLOB,\n    png:      Resource.XHR_RESPONSE_TYPE.BLOB,\n    bmp:      Resource.XHR_RESPONSE_TYPE.BLOB,\n    jpg:      Resource.XHR_RESPONSE_TYPE.BLOB,\n    jpeg:     Resource.XHR_RESPONSE_TYPE.BLOB,\n    tif:      Resource.XHR_RESPONSE_TYPE.BLOB,\n    tiff:     Resource.XHR_RESPONSE_TYPE.BLOB,\n    webp:     Resource.XHR_RESPONSE_TYPE.BLOB,\n    tga:      Resource.XHR_RESPONSE_TYPE.BLOB,\n\n    // json\n    json:     Resource.XHR_RESPONSE_TYPE.JSON,\n\n    // text\n    text:     Resource.XHR_RESPONSE_TYPE.TEXT,\n    txt:      Resource.XHR_RESPONSE_TYPE.TEXT\n};\n\n/**\n * Sets the load type to be used for a specific extension.\n *\n * @static\n * @param {string} extname - The extension to set the type for, e.g. \"png\" or \"fnt\"\n * @param {Resource.LOAD_TYPE} loadType - The load type to set it to.\n */\nResource.setExtensionLoadType = function (extname, loadType) {\n    setExtMap(Resource._loadTypeMap, extname, loadType);\n};\n\n/**\n * Sets the load type to be used for a specific extension.\n *\n * @static\n * @param {string} extname - The extension to set the type for, e.g. \"png\" or \"fnt\"\n * @param {Resource.XHR_RESPONSE_TYPE} xhrType - The xhr type to set it to.\n */\nResource.setExtensionXhrType = function (extname, xhrType) {\n    setExtMap(Resource._xhrTypeMap, extname, xhrType);\n};\n\nfunction setExtMap(map, extname, val) {\n    if (extname && extname.indexOf('.') === 0) {\n        extname = extname.substring(1);\n    }\n\n    if (!extname) {\n        return;\n    }\n\n    map[extname] = val;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}