{"ast":null,"code":"var Container = require('../display/Container'),\n    Texture = require('../textures/Texture'),\n    CanvasBuffer = require('../renderers/canvas/utils/CanvasBuffer'),\n    CanvasGraphics = require('../renderers/canvas/utils/CanvasGraphics'),\n    GraphicsData = require('./GraphicsData'),\n    math = require('../math'),\n    CONST = require('../const'),\n    tempPoint = new math.Point();\n/**\n * The Graphics class contains methods used to draw primitive shapes such as lines, circles and\n * rectangles to the display, and to color and fill them.\n *\n * @class\n * @extends PIXI.Container\n * @memberof PIXI\n */\n\n\nfunction Graphics() {\n  Container.call(this);\n  /**\n   * The alpha value used when filling the Graphics object.\n   *\n   * @member {number}\n   * @default 1\n   */\n\n  this.fillAlpha = 1;\n  /**\n   * The width (thickness) of any lines drawn.\n   *\n   * @member {number}\n   * @default 0\n   */\n\n  this.lineWidth = 0;\n  /**\n   * The color of any lines drawn.\n   *\n   * @member {string}\n   * @default 0\n   */\n\n  this.lineColor = 0;\n  /**\n   * Graphics data\n   *\n   * @member {GraphicsData[]}\n   * @private\n   */\n\n  this.graphicsData = [];\n  /**\n   * The tint applied to the graphic shape. This is a hex value. Apply a value of 0xFFFFFF to reset the tint.\n   *\n   * @member {number}\n   * @default 0xFFFFFF\n   */\n\n  this.tint = 0xFFFFFF;\n  /**\n   * The previous tint applied to the graphic shape. Used to compare to the current tint and check if theres change.\n   *\n   * @member {number}\n   * @private\n   * @default 0xFFFFFF\n   */\n\n  this._prevTint = 0xFFFFFF;\n  /**\n   * The blend mode to be applied to the graphic shape. Apply a value of blendModes.NORMAL to reset the blend mode.\n   *\n   * @member {number}\n   * @default CONST.BLEND_MODES.NORMAL;\n   */\n\n  this.blendMode = CONST.BLEND_MODES.NORMAL;\n  /**\n   * Current path\n   *\n   * @member {GraphicsData}\n   * @private\n   */\n\n  this.currentPath = null;\n  /**\n   * Array containing some WebGL-related properties used by the WebGL renderer.\n   *\n   * @member {object<number, object>}\n   * @private\n   */\n  // TODO - _webgl should use a prototype object, not a random undocumented object...\n\n  this._webGL = {};\n  /**\n   * Whether this shape is being used as a mask.\n   *\n   * @member {boolean}\n   */\n\n  this.isMask = false;\n  /**\n   * The bounds' padding used for bounds calculation.\n   *\n   * @member {number}\n   */\n\n  this.boundsPadding = 0;\n  /**\n   * A cache of the local bounds to prevent recalculation.\n   *\n   * @member {Rectangle}\n   * @private\n   */\n\n  this._localBounds = new math.Rectangle(0, 0, 1, 1);\n  /**\n   * Used to detect if the graphics object has changed. If this is set to true then the graphics\n   * object will be recalculated.\n   *\n   * @member {boolean}\n   * @private\n   */\n\n  this.dirty = true;\n  /**\n   * Used to detect if the WebGL graphics object has changed. If this is set to true then the\n   * graphics object will be recalculated.\n   *\n   * @member {boolean}\n   * @private\n   */\n\n  this.glDirty = false;\n  this.boundsDirty = true;\n  /**\n   * Used to detect if the cached sprite object needs to be updated.\n   *\n   * @member {boolean}\n   * @private\n   */\n\n  this.cachedSpriteDirty = false;\n} // constructor\n\n\nGraphics.prototype = Object.create(Container.prototype);\nGraphics.prototype.constructor = Graphics;\nmodule.exports = Graphics;\nObject.defineProperties(Graphics.prototype, {\n  /**\n   * When cacheAsBitmap is set to true the graphics object will be rendered as if it was a sprite.\n   * This is useful if your graphics element does not change often, as it will speed up the rendering\n   * of the object in exchange for taking up texture memory. It is also useful if you need the graphics\n   * object to be anti-aliased, because it will be rendered using canvas. This is not recommended if\n   * you are constantly redrawing the graphics element.\n   *\n   * @member {boolean}\n   * @memberof Graphics#\n   * @default false\n   * @private\n   */\n});\n/**\n * Creates a new Graphics object with the same values as this one.\n * Note that the only the properties of the object are cloned, not its transform (position,scale,etc)\n *\n * @return {Graphics}\n */\n\nGraphics.prototype.clone = function () {\n  var clone = new Graphics();\n  clone.renderable = this.renderable;\n  clone.fillAlpha = this.fillAlpha;\n  clone.lineWidth = this.lineWidth;\n  clone.lineColor = this.lineColor;\n  clone.tint = this.tint;\n  clone.blendMode = this.blendMode;\n  clone.isMask = this.isMask;\n  clone.boundsPadding = this.boundsPadding;\n  clone.dirty = this.dirty;\n  clone.glDirty = this.glDirty;\n  clone.cachedSpriteDirty = this.cachedSpriteDirty; // copy graphics data\n\n  for (var i = 0; i < this.graphicsData.length; ++i) {\n    clone.graphicsData.push(this.graphicsData[i].clone());\n  }\n\n  clone.currentPath = clone.graphicsData[clone.graphicsData.length - 1];\n  clone.updateLocalBounds();\n  return clone;\n};\n/**\n * Specifies the line style used for subsequent calls to Graphics methods such as the lineTo() method or the drawCircle() method.\n *\n * @param lineWidth {number} width of the line to draw, will update the objects stored style\n * @param color {number} color of the line to draw, will update the objects stored style\n * @param alpha {number} alpha of the line to draw, will update the objects stored style\n * @return {Graphics}\n */\n\n\nGraphics.prototype.lineStyle = function (lineWidth, color, alpha) {\n  this.lineWidth = lineWidth || 0;\n  this.lineColor = color || 0;\n  this.lineAlpha = alpha === undefined ? 1 : alpha;\n\n  if (this.currentPath) {\n    if (this.currentPath.shape.points.length) {\n      // halfway through a line? start a new one!\n      this.drawShape(new math.Polygon(this.currentPath.shape.points.slice(-2)));\n    } else {\n      // otherwise its empty so lets just set the line properties\n      this.currentPath.lineWidth = this.lineWidth;\n      this.currentPath.lineColor = this.lineColor;\n      this.currentPath.lineAlpha = this.lineAlpha;\n    }\n  }\n\n  return this;\n};\n/**\n * Moves the current drawing position to x, y.\n *\n * @param x {number} the X coordinate to move to\n * @param y {number} the Y coordinate to move to\n * @return {Graphics}\n  */\n\n\nGraphics.prototype.moveTo = function (x, y) {\n  this.drawShape(new math.Polygon([x, y]));\n  return this;\n};\n/**\n * Draws a line using the current line style from the current drawing position to (x, y);\n * The current drawing position is then set to (x, y).\n *\n * @param x {number} the X coordinate to draw to\n * @param y {number} the Y coordinate to draw to\n * @return {Graphics}\n */\n\n\nGraphics.prototype.lineTo = function (x, y) {\n  this.currentPath.shape.points.push(x, y);\n  this.dirty = true;\n  return this;\n};\n/**\n * Calculate the points for a quadratic bezier curve and then draws it.\n * Based on: https://stackoverflow.com/questions/785097/how-do-i-implement-a-bezier-curve-in-c\n *\n * @param cpX {number} Control point x\n * @param cpY {number} Control point y\n * @param toX {number} Destination point x\n * @param toY {number} Destination point y\n * @return {Graphics}\n */\n\n\nGraphics.prototype.quadraticCurveTo = function (cpX, cpY, toX, toY) {\n  if (this.currentPath) {\n    if (this.currentPath.shape.points.length === 0) {\n      this.currentPath.shape.points = [0, 0];\n    }\n  } else {\n    this.moveTo(0, 0);\n  }\n\n  var xa,\n      ya,\n      n = 20,\n      points = this.currentPath.shape.points;\n\n  if (points.length === 0) {\n    this.moveTo(0, 0);\n  }\n\n  var fromX = points[points.length - 2];\n  var fromY = points[points.length - 1];\n  var j = 0;\n\n  for (var i = 1; i <= n; ++i) {\n    j = i / n;\n    xa = fromX + (cpX - fromX) * j;\n    ya = fromY + (cpY - fromY) * j;\n    points.push(xa + (cpX + (toX - cpX) * j - xa) * j, ya + (cpY + (toY - cpY) * j - ya) * j);\n  }\n\n  this.dirty = this.boundsDirty = true;\n  return this;\n};\n/**\n * Calculate the points for a bezier curve and then draws it.\n *\n * @param cpX {number} Control point x\n * @param cpY {number} Control point y\n * @param cpX2 {number} Second Control point x\n * @param cpY2 {number} Second Control point y\n * @param toX {number} Destination point x\n * @param toY {number} Destination point y\n * @return {Graphics}\n */\n\n\nGraphics.prototype.bezierCurveTo = function (cpX, cpY, cpX2, cpY2, toX, toY) {\n  if (this.currentPath) {\n    if (this.currentPath.shape.points.length === 0) {\n      this.currentPath.shape.points = [0, 0];\n    }\n  } else {\n    this.moveTo(0, 0);\n  }\n\n  var n = 20,\n      dt,\n      dt2,\n      dt3,\n      t2,\n      t3,\n      points = this.currentPath.shape.points;\n  var fromX = points[points.length - 2];\n  var fromY = points[points.length - 1];\n  var j = 0;\n\n  for (var i = 1; i <= n; ++i) {\n    j = i / n;\n    dt = 1 - j;\n    dt2 = dt * dt;\n    dt3 = dt2 * dt;\n    t2 = j * j;\n    t3 = t2 * j;\n    points.push(dt3 * fromX + 3 * dt2 * j * cpX + 3 * dt * t2 * cpX2 + t3 * toX, dt3 * fromY + 3 * dt2 * j * cpY + 3 * dt * t2 * cpY2 + t3 * toY);\n  }\n\n  this.dirty = this.boundsDirty = true;\n  return this;\n};\n/**\n * The arcTo() method creates an arc/curve between two tangents on the canvas.\n *\n * \"borrowed\" from https://code.google.com/p/fxcanvas/ - thanks google!\n *\n * @param x1 {number} The x-coordinate of the beginning of the arc\n * @param y1 {number} The y-coordinate of the beginning of the arc\n * @param x2 {number} The x-coordinate of the end of the arc\n * @param y2 {number} The y-coordinate of the end of the arc\n * @param radius {number} The radius of the arc\n * @return {Graphics}\n */\n\n\nGraphics.prototype.arcTo = function (x1, y1, x2, y2, radius) {\n  if (this.currentPath) {\n    if (this.currentPath.shape.points.length === 0) {\n      this.currentPath.shape.points.push(x1, y1);\n    }\n  } else {\n    this.moveTo(x1, y1);\n  }\n\n  var points = this.currentPath.shape.points,\n      fromX = points[points.length - 2],\n      fromY = points[points.length - 1],\n      a1 = fromY - y1,\n      b1 = fromX - x1,\n      a2 = y2 - y1,\n      b2 = x2 - x1,\n      mm = Math.abs(a1 * b2 - b1 * a2);\n\n  if (mm < 1.0e-8 || radius === 0) {\n    if (points[points.length - 2] !== x1 || points[points.length - 1] !== y1) {\n      points.push(x1, y1);\n    }\n  } else {\n    var dd = a1 * a1 + b1 * b1,\n        cc = a2 * a2 + b2 * b2,\n        tt = a1 * a2 + b1 * b2,\n        k1 = radius * Math.sqrt(dd) / mm,\n        k2 = radius * Math.sqrt(cc) / mm,\n        j1 = k1 * tt / dd,\n        j2 = k2 * tt / cc,\n        cx = k1 * b2 + k2 * b1,\n        cy = k1 * a2 + k2 * a1,\n        px = b1 * (k2 + j1),\n        py = a1 * (k2 + j1),\n        qx = b2 * (k1 + j2),\n        qy = a2 * (k1 + j2),\n        startAngle = Math.atan2(py - cy, px - cx),\n        endAngle = Math.atan2(qy - cy, qx - cx);\n    this.arc(cx + x1, cy + y1, radius, startAngle, endAngle, b1 * a2 > b2 * a1);\n  }\n\n  this.dirty = this.boundsDirty = true;\n  return this;\n};\n/**\n * The arc method creates an arc/curve (used to create circles, or parts of circles).\n *\n * @param cx {number} The x-coordinate of the center of the circle\n * @param cy {number} The y-coordinate of the center of the circle\n * @param radius {number} The radius of the circle\n * @param startAngle {number} The starting angle, in radians (0 is at the 3 o'clock position of the arc's circle)\n * @param endAngle {number} The ending angle, in radians\n * @param anticlockwise {boolean} Optional. Specifies whether the drawing should be counterclockwise or clockwise. False is default, and indicates clockwise, while true indicates counter-clockwise.\n * @return {Graphics}\n */\n\n\nGraphics.prototype.arc = function (cx, cy, radius, startAngle, endAngle, anticlockwise) {\n  anticlockwise = anticlockwise || false;\n\n  if (startAngle === endAngle) {\n    return this;\n  }\n\n  if (!anticlockwise && endAngle <= startAngle) {\n    endAngle += Math.PI * 2;\n  } else if (anticlockwise && startAngle <= endAngle) {\n    startAngle += Math.PI * 2;\n  }\n\n  var sweep = anticlockwise ? (startAngle - endAngle) * -1 : endAngle - startAngle;\n  var segs = Math.ceil(Math.abs(sweep) / (Math.PI * 2)) * 40;\n\n  if (sweep === 0) {\n    return this;\n  }\n\n  var startX = cx + Math.cos(startAngle) * radius;\n  var startY = cy + Math.sin(startAngle) * radius;\n\n  if (this.currentPath) {\n    if (anticlockwise && this.filling) {\n      this.currentPath.shape.points.push(cx, cy);\n    } else {\n      this.currentPath.shape.points.push(startX, startY);\n    }\n  } else {\n    if (anticlockwise && this.filling) {\n      this.moveTo(cx, cy);\n    } else {\n      this.moveTo(startX, startY);\n    }\n  }\n\n  var points = this.currentPath.shape.points;\n  var theta = sweep / (segs * 2);\n  var theta2 = theta * 2;\n  var cTheta = Math.cos(theta);\n  var sTheta = Math.sin(theta);\n  var segMinus = segs - 1;\n  var remainder = segMinus % 1 / segMinus;\n\n  for (var i = 0; i <= segMinus; i++) {\n    var real = i + remainder * i;\n    var angle = theta + startAngle + theta2 * real;\n    var c = Math.cos(angle);\n    var s = -Math.sin(angle);\n    points.push((cTheta * c + sTheta * s) * radius + cx, (cTheta * -s + sTheta * c) * radius + cy);\n  }\n\n  this.dirty = this.boundsDirty = true;\n  return this;\n};\n/**\n * Specifies a simple one-color fill that subsequent calls to other Graphics methods\n * (such as lineTo() or drawCircle()) use when drawing.\n *\n * @param color {number} the color of the fill\n * @param alpha {number} the alpha of the fill\n * @return {Graphics}\n */\n\n\nGraphics.prototype.beginFill = function (color, alpha) {\n  this.filling = true;\n  this.fillColor = color || 0;\n  this.fillAlpha = alpha === undefined ? 1 : alpha;\n\n  if (this.currentPath) {\n    if (this.currentPath.shape.points.length <= 2) {\n      this.currentPath.fill = this.filling;\n      this.currentPath.fillColor = this.fillColor;\n      this.currentPath.fillAlpha = this.fillAlpha;\n    }\n  }\n\n  return this;\n};\n/**\n * Applies a fill to the lines and shapes that were added since the last call to the beginFill() method.\n *\n * @return {Graphics}\n */\n\n\nGraphics.prototype.endFill = function () {\n  this.filling = false;\n  this.fillColor = null;\n  this.fillAlpha = 1;\n  return this;\n};\n/**\n *\n * @param x {number} The X coord of the top-left of the rectangle\n * @param y {number} The Y coord of the top-left of the rectangle\n * @param width {number} The width of the rectangle\n * @param height {number} The height of the rectangle\n * @return {Graphics}\n */\n\n\nGraphics.prototype.drawRect = function (x, y, width, height) {\n  this.drawShape(new math.Rectangle(x, y, width, height));\n  return this;\n};\n/**\n *\n * @param x {number} The X coord of the top-left of the rectangle\n * @param y {number} The Y coord of the top-left of the rectangle\n * @param width {number} The width of the rectangle\n * @param height {number} The height of the rectangle\n * @param radius {number} Radius of the rectangle corners\n */\n\n\nGraphics.prototype.drawRoundedRect = function (x, y, width, height, radius) {\n  this.drawShape(new math.RoundedRectangle(x, y, width, height, radius));\n  return this;\n};\n/**\n * Draws a circle.\n *\n * @param x {number} The X coordinate of the center of the circle\n * @param y {number} The Y coordinate of the center of the circle\n * @param radius {number} The radius of the circle\n * @return {Graphics}\n */\n\n\nGraphics.prototype.drawCircle = function (x, y, radius) {\n  this.drawShape(new math.Circle(x, y, radius));\n  return this;\n};\n/**\n * Draws an ellipse.\n *\n * @param x {number} The X coordinate of the center of the ellipse\n * @param y {number} The Y coordinate of the center of the ellipse\n * @param width {number} The half width of the ellipse\n * @param height {number} The half height of the ellipse\n * @return {Graphics}\n */\n\n\nGraphics.prototype.drawEllipse = function (x, y, width, height) {\n  this.drawShape(new math.Ellipse(x, y, width, height));\n  return this;\n};\n/**\n * Draws a polygon using the given path.\n *\n * @param path {Array} The path data used to construct the polygon.\n * @return {Graphics}\n */\n\n\nGraphics.prototype.drawPolygon = function (path) {\n  // prevents an argument assignment deopt\n  // see section 3.1: https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#3-managing-arguments\n  var points = path;\n\n  if (!Array.isArray(points)) {\n    // prevents an argument leak deopt\n    // see section 3.2: https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#3-managing-arguments\n    points = new Array(arguments.length);\n\n    for (var i = 0; i < points.length; ++i) {\n      points[i] = arguments[i];\n    }\n  }\n\n  this.drawShape(new math.Polygon(points));\n  return this;\n};\n/**\n * Clears the graphics that were drawn to this Graphics object, and resets fill and line style settings.\n *\n * @return {Graphics}\n */\n\n\nGraphics.prototype.clear = function () {\n  this.lineWidth = 0;\n  this.filling = false;\n  this.dirty = true;\n  this.clearDirty = true;\n  this.graphicsData = [];\n  return this;\n};\n/**\n * Useful function that returns a texture of the graphics object that can then be used to create sprites\n * This can be quite useful if your geometry is complicated and needs to be reused multiple times.\n *\n * @param resolution {number} The resolution of the texture being generated\n * @param scaleMode {number} Should be one of the scaleMode consts\n * @return {Texture} a texture of the graphics object\n */\n\n\nGraphics.prototype.generateTexture = function (renderer, resolution, scaleMode) {\n  resolution = resolution || 1;\n  var bounds = this.getLocalBounds();\n  var canvasBuffer = new CanvasBuffer(bounds.width * resolution, bounds.height * resolution);\n  var texture = Texture.fromCanvas(canvasBuffer.canvas, scaleMode);\n  texture.baseTexture.resolution = resolution;\n  canvasBuffer.context.scale(resolution, resolution);\n  canvasBuffer.context.translate(-bounds.x, -bounds.y);\n  CanvasGraphics.renderGraphics(this, canvasBuffer.context);\n  return texture;\n};\n/**\n * Renders the object using the WebGL renderer\n *\n * @param renderer {WebGLRenderer}\n * @private\n */\n\n\nGraphics.prototype._renderWebGL = function (renderer) {\n  // if the sprite is not visible or the alpha is 0 then no need to render this element\n  // this code may still be needed so leaving for now..\n  //\n\n  /*\n  if (this._cacheAsBitmap)\n  {\n      if (this.dirty || this.cachedSpriteDirty)\n      {\n          this._generateCachedSprite();\n           // we will also need to update the texture on the gpu too!\n          this.updateCachedSpriteTexture();\n           this.cachedSpriteDirty = false;\n          this.dirty = false;\n      }\n       this._cachedSprite.worldAlpha = this.worldAlpha;\n       Sprite.prototype.renderWebGL.call(this._cachedSprite, renderer);\n       return;\n  }\n   */\n  if (this.glDirty) {\n    this.dirty = true;\n    this.glDirty = false;\n  }\n\n  renderer.setObjectRenderer(renderer.plugins.graphics);\n  renderer.plugins.graphics.render(this);\n};\n/**\n * Renders the object using the Canvas renderer\n *\n * @param renderer {CanvasRenderer}\n * @private\n */\n\n\nGraphics.prototype._renderCanvas = function (renderer) {\n  if (this.isMask === true) {\n    return;\n  } // if the tint has changed, set the graphics object to dirty.\n\n\n  if (this._prevTint !== this.tint) {\n    this.dirty = true;\n    this._prevTint = this.tint;\n  } // this code may still be needed so leaving for now..\n  //\n\n  /*\n  if (this._cacheAsBitmap)\n  {\n      if (this.dirty || this.cachedSpriteDirty)\n      {\n          this._generateCachedSprite();\n           // we will also need to update the texture\n          this.updateCachedSpriteTexture();\n           this.cachedSpriteDirty = false;\n          this.dirty = false;\n      }\n       this._cachedSprite.alpha = this.alpha;\n       Sprite.prototype._renderCanvas.call(this._cachedSprite, renderer);\n       return;\n  }\n  */\n\n\n  var context = renderer.context;\n  var transform = this.worldTransform;\n\n  if (this.blendMode !== renderer.currentBlendMode) {\n    renderer.currentBlendMode = this.blendMode;\n    context.globalCompositeOperation = renderer.blendModes[renderer.currentBlendMode];\n  }\n\n  var resolution = renderer.resolution;\n  context.setTransform(transform.a * resolution, transform.b * resolution, transform.c * resolution, transform.d * resolution, transform.tx * resolution, transform.ty * resolution);\n  CanvasGraphics.renderGraphics(this, context);\n};\n/**\n * Retrieves the bounds of the graphic shape as a rectangle object\n *\n * @return {Rectangle} the rectangular bounding area\n */\n\n\nGraphics.prototype.getBounds = function (matrix) {\n  if (!this._currentBounds) {\n    // return an empty object if the item is a mask!\n    if (!this.renderable) {\n      return math.Rectangle.EMPTY;\n    }\n\n    if (this.boundsDirty) {\n      this.updateLocalBounds();\n      this.glDirty = true;\n      this.cachedSpriteDirty = true;\n      this.boundsDirty = false;\n    }\n\n    var bounds = this._localBounds;\n    var w0 = bounds.x;\n    var w1 = bounds.width + bounds.x;\n    var h0 = bounds.y;\n    var h1 = bounds.height + bounds.y;\n    var worldTransform = matrix || this.worldTransform;\n    var a = worldTransform.a;\n    var b = worldTransform.b;\n    var c = worldTransform.c;\n    var d = worldTransform.d;\n    var tx = worldTransform.tx;\n    var ty = worldTransform.ty;\n    var x1 = a * w1 + c * h1 + tx;\n    var y1 = d * h1 + b * w1 + ty;\n    var x2 = a * w0 + c * h1 + tx;\n    var y2 = d * h1 + b * w0 + ty;\n    var x3 = a * w0 + c * h0 + tx;\n    var y3 = d * h0 + b * w0 + ty;\n    var x4 = a * w1 + c * h0 + tx;\n    var y4 = d * h0 + b * w1 + ty;\n    var maxX = x1;\n    var maxY = y1;\n    var minX = x1;\n    var minY = y1;\n    minX = x2 < minX ? x2 : minX;\n    minX = x3 < minX ? x3 : minX;\n    minX = x4 < minX ? x4 : minX;\n    minY = y2 < minY ? y2 : minY;\n    minY = y3 < minY ? y3 : minY;\n    minY = y4 < minY ? y4 : minY;\n    maxX = x2 > maxX ? x2 : maxX;\n    maxX = x3 > maxX ? x3 : maxX;\n    maxX = x4 > maxX ? x4 : maxX;\n    maxY = y2 > maxY ? y2 : maxY;\n    maxY = y3 > maxY ? y3 : maxY;\n    maxY = y4 > maxY ? y4 : maxY;\n    this._bounds.x = minX;\n    this._bounds.width = maxX - minX;\n    this._bounds.y = minY;\n    this._bounds.height = maxY - minY;\n    this._currentBounds = this._bounds;\n  }\n\n  return this._currentBounds;\n};\n/**\n* Tests if a point is inside this graphics object\n*\n* @param point {Point} the point to test\n* @return {boolean} the result of the test\n*/\n\n\nGraphics.prototype.containsPoint = function (point) {\n  this.worldTransform.applyInverse(point, tempPoint);\n  var graphicsData = this.graphicsData;\n\n  for (var i = 0; i < graphicsData.length; i++) {\n    var data = graphicsData[i];\n\n    if (!data.fill) {\n      continue;\n    } // only deal with fills..\n\n\n    if (data.shape) {\n      if (data.shape.contains(tempPoint.x, tempPoint.y)) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n};\n/**\n * Update the bounds of the object\n *\n */\n\n\nGraphics.prototype.updateLocalBounds = function () {\n  var minX = Infinity;\n  var maxX = -Infinity;\n  var minY = Infinity;\n  var maxY = -Infinity;\n\n  if (this.graphicsData.length) {\n    var shape, points, x, y, w, h;\n\n    for (var i = 0; i < this.graphicsData.length; i++) {\n      var data = this.graphicsData[i];\n      var type = data.type;\n      var lineWidth = data.lineWidth;\n      shape = data.shape;\n\n      if (type === CONST.SHAPES.RECT || type === CONST.SHAPES.RREC) {\n        x = shape.x - lineWidth / 2;\n        y = shape.y - lineWidth / 2;\n        w = shape.width + lineWidth;\n        h = shape.height + lineWidth;\n        minX = x < minX ? x : minX;\n        maxX = x + w > maxX ? x + w : maxX;\n        minY = y < minY ? y : minY;\n        maxY = y + h > maxY ? y + h : maxY;\n      } else if (type === CONST.SHAPES.CIRC) {\n        x = shape.x;\n        y = shape.y;\n        w = shape.radius + lineWidth / 2;\n        h = shape.radius + lineWidth / 2;\n        minX = x - w < minX ? x - w : minX;\n        maxX = x + w > maxX ? x + w : maxX;\n        minY = y - h < minY ? y - h : minY;\n        maxY = y + h > maxY ? y + h : maxY;\n      } else if (type === CONST.SHAPES.ELIP) {\n        x = shape.x;\n        y = shape.y;\n        w = shape.width + lineWidth / 2;\n        h = shape.height + lineWidth / 2;\n        minX = x - w < minX ? x - w : minX;\n        maxX = x + w > maxX ? x + w : maxX;\n        minY = y - h < minY ? y - h : minY;\n        maxY = y + h > maxY ? y + h : maxY;\n      } else {\n        // POLY\n        points = shape.points;\n\n        for (var j = 0; j < points.length; j += 2) {\n          x = points[j];\n          y = points[j + 1];\n          minX = x - lineWidth < minX ? x - lineWidth : minX;\n          maxX = x + lineWidth > maxX ? x + lineWidth : maxX;\n          minY = y - lineWidth < minY ? y - lineWidth : minY;\n          maxY = y + lineWidth > maxY ? y + lineWidth : maxY;\n        }\n      }\n    }\n  } else {\n    minX = 0;\n    maxX = 0;\n    minY = 0;\n    maxY = 0;\n  }\n\n  var padding = this.boundsPadding;\n  this._localBounds.x = minX - padding;\n  this._localBounds.width = maxX - minX + padding * 2;\n  this._localBounds.y = minY - padding;\n  this._localBounds.height = maxY - minY + padding * 2;\n};\n/**\n * Generates the cached sprite when the sprite has cacheAsBitmap = true\n *\n * @private\n */\n\n/*\nGraphics.prototype._generateCachedSprite = function ()\n{\n    var bounds = this.getLocalBounds();\n\n    if (!this._cachedSprite)\n    {\n        var canvasBuffer = new CanvasBuffer(bounds.width, bounds.height);\n        var texture = Texture.fromCanvas(canvasBuffer.canvas);\n\n        this._cachedSprite = new Sprite(texture);\n        this._cachedSprite.buffer = canvasBuffer;\n\n        this._cachedSprite.worldTransform = this.worldTransform;\n    }\n    else\n    {\n        this._cachedSprite.buffer.resize(bounds.width, bounds.height);\n    }\n\n    // leverage the anchor to account for the offset of the element\n    this._cachedSprite.anchor.x = -( bounds.x / bounds.width );\n    this._cachedSprite.anchor.y = -( bounds.y / bounds.height );\n\n    // this._cachedSprite.buffer.context.save();\n    this._cachedSprite.buffer.context.translate(-bounds.x,-bounds.y);\n\n    // make sure we set the alpha of the graphics to 1 for the render..\n    this.worldAlpha = 1;\n\n    // now render the graphic..\n    CanvasGraphics.renderGraphics(this, this._cachedSprite.buffer.context);\n\n    this._cachedSprite.alpha = this.alpha;\n};\n*/\n\n/**\n * Updates texture size based on canvas size\n *\n * @private\n */\n\n/*\nGraphics.prototype.updateCachedSpriteTexture = function ()\n{\n    var cachedSprite = this._cachedSprite;\n    var texture = cachedSprite.texture;\n    var canvas = cachedSprite.buffer.canvas;\n\n    texture.baseTexture.width = canvas.width;\n    texture.baseTexture.height = canvas.height;\n    texture.crop.width = texture.frame.width = canvas.width;\n    texture.crop.height = texture.frame.height = canvas.height;\n\n    cachedSprite._width = canvas.width;\n    cachedSprite._height = canvas.height;\n\n    // update the dirty base textures\n    texture.baseTexture.dirty();\n};*/\n\n/**\n * Destroys a previous cached sprite.\n *\n */\n\n/*\nGraphics.prototype.destroyCachedSprite = function ()\n{\n    this._cachedSprite.texture.destroy(true);\n\n    // let the gc collect the unused sprite\n    // TODO could be object pooled!\n    this._cachedSprite = null;\n};*/\n\n/**\n * Draws the given shape to this Graphics object. Can be any of Circle, Rectangle, Ellipse, Line or Polygon.\n *\n * @param shape {Circle|Rectangle|Ellipse|Line|Polygon} The shape object to draw.\n * @return {GraphicsData} The generated GraphicsData object.\n */\n\n\nGraphics.prototype.drawShape = function (shape) {\n  if (this.currentPath) {\n    // check current path!\n    if (this.currentPath.shape.points.length <= 2) {\n      this.graphicsData.pop();\n    }\n  }\n\n  this.currentPath = null;\n  var data = new GraphicsData(this.lineWidth, this.lineColor, this.lineAlpha, this.fillColor, this.fillAlpha, this.filling, shape);\n  this.graphicsData.push(data);\n\n  if (data.type === CONST.SHAPES.POLY) {\n    data.shape.closed = data.shape.closed || this.filling;\n    this.currentPath = data;\n  }\n\n  this.dirty = this.boundsDirty = true;\n  return data;\n};\n\nGraphics.prototype.destroy = function () {\n  Container.prototype.destroy.apply(this, arguments); // destroy each of the GraphicsData objects\n\n  for (var i = 0; i < this.graphicsData.length; ++i) {\n    this.graphicsData[i].destroy();\n  } // for each webgl data entry, destroy the WebGLGraphicsData\n\n\n  for (var id in this._webgl) {\n    for (var j = 0; j < this._webgl[id].data.length; ++j) {\n      this._webgl[id].data[j].destroy();\n    }\n  }\n\n  this.graphicsData = null;\n  this.currentPath = null;\n  this._webgl = null;\n  this._localBounds = null;\n};","map":{"version":3,"names":["Container","require","Texture","CanvasBuffer","CanvasGraphics","GraphicsData","math","CONST","tempPoint","Point","Graphics","call","fillAlpha","lineWidth","lineColor","graphicsData","tint","_prevTint","blendMode","BLEND_MODES","NORMAL","currentPath","_webGL","isMask","boundsPadding","_localBounds","Rectangle","dirty","glDirty","boundsDirty","cachedSpriteDirty","prototype","Object","create","constructor","module","exports","defineProperties","clone","renderable","i","length","push","updateLocalBounds","lineStyle","color","alpha","lineAlpha","undefined","shape","points","drawShape","Polygon","slice","moveTo","x","y","lineTo","quadraticCurveTo","cpX","cpY","toX","toY","xa","ya","n","fromX","fromY","j","bezierCurveTo","cpX2","cpY2","dt","dt2","dt3","t2","t3","arcTo","x1","y1","x2","y2","radius","a1","b1","a2","b2","mm","Math","abs","dd","cc","tt","k1","sqrt","k2","j1","j2","cx","cy","px","py","qx","qy","startAngle","atan2","endAngle","arc","anticlockwise","PI","sweep","segs","ceil","startX","cos","startY","sin","filling","theta","theta2","cTheta","sTheta","segMinus","remainder","real","angle","c","s","beginFill","fillColor","fill","endFill","drawRect","width","height","drawRoundedRect","RoundedRectangle","drawCircle","Circle","drawEllipse","Ellipse","drawPolygon","path","Array","isArray","arguments","clear","clearDirty","generateTexture","renderer","resolution","scaleMode","bounds","getLocalBounds","canvasBuffer","texture","fromCanvas","canvas","baseTexture","context","scale","translate","renderGraphics","_renderWebGL","setObjectRenderer","plugins","graphics","render","_renderCanvas","transform","worldTransform","currentBlendMode","globalCompositeOperation","blendModes","setTransform","a","b","d","tx","ty","getBounds","matrix","_currentBounds","EMPTY","w0","w1","h0","h1","x3","y3","x4","y4","maxX","maxY","minX","minY","_bounds","containsPoint","point","applyInverse","data","contains","Infinity","w","h","type","SHAPES","RECT","RREC","CIRC","ELIP","padding","pop","POLY","closed","destroy","apply","id","_webgl"],"sources":["/home/reyden-martin/Documents/Tech2/HUB/Sony CSL/SONY-CSL-PROJECT/node_modules/react-piano-roll/node_modules/pixi.js/src/core/graphics/Graphics.js"],"sourcesContent":["var Container = require('../display/Container'),\n    Texture = require('../textures/Texture'),\n    CanvasBuffer = require('../renderers/canvas/utils/CanvasBuffer'),\n    CanvasGraphics = require('../renderers/canvas/utils/CanvasGraphics'),\n    GraphicsData = require('./GraphicsData'),\n    math = require('../math'),\n    CONST = require('../const'),\n    tempPoint = new math.Point();\n\n/**\n * The Graphics class contains methods used to draw primitive shapes such as lines, circles and\n * rectangles to the display, and to color and fill them.\n *\n * @class\n * @extends PIXI.Container\n * @memberof PIXI\n */\nfunction Graphics()\n{\n    Container.call(this);\n\n    /**\n     * The alpha value used when filling the Graphics object.\n     *\n     * @member {number}\n     * @default 1\n     */\n    this.fillAlpha = 1;\n\n    /**\n     * The width (thickness) of any lines drawn.\n     *\n     * @member {number}\n     * @default 0\n     */\n    this.lineWidth = 0;\n\n    /**\n     * The color of any lines drawn.\n     *\n     * @member {string}\n     * @default 0\n     */\n    this.lineColor = 0;\n\n    /**\n     * Graphics data\n     *\n     * @member {GraphicsData[]}\n     * @private\n     */\n    this.graphicsData = [];\n\n    /**\n     * The tint applied to the graphic shape. This is a hex value. Apply a value of 0xFFFFFF to reset the tint.\n     *\n     * @member {number}\n     * @default 0xFFFFFF\n     */\n    this.tint = 0xFFFFFF;\n\n    /**\n     * The previous tint applied to the graphic shape. Used to compare to the current tint and check if theres change.\n     *\n     * @member {number}\n     * @private\n     * @default 0xFFFFFF\n     */\n    this._prevTint = 0xFFFFFF;\n\n    /**\n     * The blend mode to be applied to the graphic shape. Apply a value of blendModes.NORMAL to reset the blend mode.\n     *\n     * @member {number}\n     * @default CONST.BLEND_MODES.NORMAL;\n     */\n    this.blendMode = CONST.BLEND_MODES.NORMAL;\n\n    /**\n     * Current path\n     *\n     * @member {GraphicsData}\n     * @private\n     */\n    this.currentPath = null;\n\n    /**\n     * Array containing some WebGL-related properties used by the WebGL renderer.\n     *\n     * @member {object<number, object>}\n     * @private\n     */\n    // TODO - _webgl should use a prototype object, not a random undocumented object...\n    this._webGL = {};\n\n    /**\n     * Whether this shape is being used as a mask.\n     *\n     * @member {boolean}\n     */\n    this.isMask = false;\n\n    /**\n     * The bounds' padding used for bounds calculation.\n     *\n     * @member {number}\n     */\n    this.boundsPadding = 0;\n\n    /**\n     * A cache of the local bounds to prevent recalculation.\n     *\n     * @member {Rectangle}\n     * @private\n     */\n    this._localBounds = new math.Rectangle(0,0,1,1);\n\n    /**\n     * Used to detect if the graphics object has changed. If this is set to true then the graphics\n     * object will be recalculated.\n     *\n     * @member {boolean}\n     * @private\n     */\n    this.dirty = true;\n\n    /**\n     * Used to detect if the WebGL graphics object has changed. If this is set to true then the\n     * graphics object will be recalculated.\n     *\n     * @member {boolean}\n     * @private\n     */\n    this.glDirty = false;\n\n    this.boundsDirty = true;\n\n    /**\n     * Used to detect if the cached sprite object needs to be updated.\n     *\n     * @member {boolean}\n     * @private\n     */\n    this.cachedSpriteDirty = false;\n}\n\n// constructor\nGraphics.prototype = Object.create(Container.prototype);\nGraphics.prototype.constructor = Graphics;\nmodule.exports = Graphics;\n\nObject.defineProperties(Graphics.prototype, {\n    /**\n     * When cacheAsBitmap is set to true the graphics object will be rendered as if it was a sprite.\n     * This is useful if your graphics element does not change often, as it will speed up the rendering\n     * of the object in exchange for taking up texture memory. It is also useful if you need the graphics\n     * object to be anti-aliased, because it will be rendered using canvas. This is not recommended if\n     * you are constantly redrawing the graphics element.\n     *\n     * @member {boolean}\n     * @memberof Graphics#\n     * @default false\n     * @private\n     */\n\n});\n\n/**\n * Creates a new Graphics object with the same values as this one.\n * Note that the only the properties of the object are cloned, not its transform (position,scale,etc)\n *\n * @return {Graphics}\n */\nGraphics.prototype.clone = function ()\n{\n    var clone = new Graphics();\n\n    clone.renderable    = this.renderable;\n    clone.fillAlpha     = this.fillAlpha;\n    clone.lineWidth     = this.lineWidth;\n    clone.lineColor     = this.lineColor;\n    clone.tint          = this.tint;\n    clone.blendMode     = this.blendMode;\n    clone.isMask        = this.isMask;\n    clone.boundsPadding = this.boundsPadding;\n    clone.dirty         = this.dirty;\n    clone.glDirty       = this.glDirty;\n    clone.cachedSpriteDirty = this.cachedSpriteDirty;\n\n    // copy graphics data\n    for (var i = 0; i < this.graphicsData.length; ++i)\n    {\n        clone.graphicsData.push(this.graphicsData[i].clone());\n    }\n\n    clone.currentPath = clone.graphicsData[clone.graphicsData.length - 1];\n\n    clone.updateLocalBounds();\n\n    return clone;\n};\n\n/**\n * Specifies the line style used for subsequent calls to Graphics methods such as the lineTo() method or the drawCircle() method.\n *\n * @param lineWidth {number} width of the line to draw, will update the objects stored style\n * @param color {number} color of the line to draw, will update the objects stored style\n * @param alpha {number} alpha of the line to draw, will update the objects stored style\n * @return {Graphics}\n */\nGraphics.prototype.lineStyle = function (lineWidth, color, alpha)\n{\n    this.lineWidth = lineWidth || 0;\n    this.lineColor = color || 0;\n    this.lineAlpha = (alpha === undefined) ? 1 : alpha;\n\n    if (this.currentPath)\n    {\n        if (this.currentPath.shape.points.length)\n        {\n            // halfway through a line? start a new one!\n            this.drawShape( new math.Polygon( this.currentPath.shape.points.slice(-2) ));\n        }\n        else\n        {\n            // otherwise its empty so lets just set the line properties\n            this.currentPath.lineWidth = this.lineWidth;\n            this.currentPath.lineColor = this.lineColor;\n            this.currentPath.lineAlpha = this.lineAlpha;\n        }\n    }\n\n    return this;\n};\n\n/**\n * Moves the current drawing position to x, y.\n *\n * @param x {number} the X coordinate to move to\n * @param y {number} the Y coordinate to move to\n * @return {Graphics}\n  */\nGraphics.prototype.moveTo = function (x, y)\n{\n    this.drawShape(new math.Polygon([x,y]));\n\n    return this;\n};\n\n/**\n * Draws a line using the current line style from the current drawing position to (x, y);\n * The current drawing position is then set to (x, y).\n *\n * @param x {number} the X coordinate to draw to\n * @param y {number} the Y coordinate to draw to\n * @return {Graphics}\n */\nGraphics.prototype.lineTo = function (x, y)\n{\n    this.currentPath.shape.points.push(x, y);\n    this.dirty = true;\n\n    return this;\n};\n\n/**\n * Calculate the points for a quadratic bezier curve and then draws it.\n * Based on: https://stackoverflow.com/questions/785097/how-do-i-implement-a-bezier-curve-in-c\n *\n * @param cpX {number} Control point x\n * @param cpY {number} Control point y\n * @param toX {number} Destination point x\n * @param toY {number} Destination point y\n * @return {Graphics}\n */\nGraphics.prototype.quadraticCurveTo = function (cpX, cpY, toX, toY)\n{\n    if (this.currentPath)\n    {\n        if (this.currentPath.shape.points.length === 0)\n        {\n            this.currentPath.shape.points = [0, 0];\n        }\n    }\n    else\n    {\n        this.moveTo(0,0);\n    }\n\n    var xa,\n        ya,\n        n = 20,\n        points = this.currentPath.shape.points;\n\n    if (points.length === 0)\n    {\n        this.moveTo(0, 0);\n    }\n\n    var fromX = points[points.length-2];\n    var fromY = points[points.length-1];\n\n    var j = 0;\n    for (var i = 1; i <= n; ++i)\n    {\n        j = i / n;\n\n        xa = fromX + ( (cpX - fromX) * j );\n        ya = fromY + ( (cpY - fromY) * j );\n\n        points.push( xa + ( ((cpX + ( (toX - cpX) * j )) - xa) * j ),\n                     ya + ( ((cpY + ( (toY - cpY) * j )) - ya) * j ) );\n    }\n\n    this.dirty = this.boundsDirty = true;\n\n    return this;\n};\n\n/**\n * Calculate the points for a bezier curve and then draws it.\n *\n * @param cpX {number} Control point x\n * @param cpY {number} Control point y\n * @param cpX2 {number} Second Control point x\n * @param cpY2 {number} Second Control point y\n * @param toX {number} Destination point x\n * @param toY {number} Destination point y\n * @return {Graphics}\n */\nGraphics.prototype.bezierCurveTo = function (cpX, cpY, cpX2, cpY2, toX, toY)\n{\n    if (this.currentPath)\n    {\n        if (this.currentPath.shape.points.length === 0)\n        {\n            this.currentPath.shape.points = [0, 0];\n        }\n    }\n    else\n    {\n        this.moveTo(0,0);\n    }\n\n    var n = 20,\n        dt,\n        dt2,\n        dt3,\n        t2,\n        t3,\n        points = this.currentPath.shape.points;\n\n    var fromX = points[points.length-2];\n    var fromY = points[points.length-1];\n\n    var j = 0;\n\n    for (var i = 1; i <= n; ++i)\n    {\n        j = i / n;\n\n        dt = (1 - j);\n        dt2 = dt * dt;\n        dt3 = dt2 * dt;\n\n        t2 = j * j;\n        t3 = t2 * j;\n\n        points.push( dt3 * fromX + 3 * dt2 * j * cpX + 3 * dt * t2 * cpX2 + t3 * toX,\n                     dt3 * fromY + 3 * dt2 * j * cpY + 3 * dt * t2 * cpY2 + t3 * toY);\n    }\n\n    this.dirty = this.boundsDirty = true;\n\n    return this;\n};\n\n/**\n * The arcTo() method creates an arc/curve between two tangents on the canvas.\n *\n * \"borrowed\" from https://code.google.com/p/fxcanvas/ - thanks google!\n *\n * @param x1 {number} The x-coordinate of the beginning of the arc\n * @param y1 {number} The y-coordinate of the beginning of the arc\n * @param x2 {number} The x-coordinate of the end of the arc\n * @param y2 {number} The y-coordinate of the end of the arc\n * @param radius {number} The radius of the arc\n * @return {Graphics}\n */\nGraphics.prototype.arcTo = function (x1, y1, x2, y2, radius)\n{\n    if (this.currentPath)\n    {\n        if (this.currentPath.shape.points.length === 0)\n        {\n            this.currentPath.shape.points.push(x1, y1);\n        }\n    }\n    else\n    {\n        this.moveTo(x1, y1);\n    }\n\n    var points = this.currentPath.shape.points,\n        fromX = points[points.length-2],\n        fromY = points[points.length-1],\n        a1 = fromY - y1,\n        b1 = fromX - x1,\n        a2 = y2   - y1,\n        b2 = x2   - x1,\n        mm = Math.abs(a1 * b2 - b1 * a2);\n\n    if (mm < 1.0e-8 || radius === 0)\n    {\n        if (points[points.length-2] !== x1 || points[points.length-1] !== y1)\n        {\n            points.push(x1, y1);\n        }\n    }\n    else\n    {\n        var dd = a1 * a1 + b1 * b1,\n            cc = a2 * a2 + b2 * b2,\n            tt = a1 * a2 + b1 * b2,\n            k1 = radius * Math.sqrt(dd) / mm,\n            k2 = radius * Math.sqrt(cc) / mm,\n            j1 = k1 * tt / dd,\n            j2 = k2 * tt / cc,\n            cx = k1 * b2 + k2 * b1,\n            cy = k1 * a2 + k2 * a1,\n            px = b1 * (k2 + j1),\n            py = a1 * (k2 + j1),\n            qx = b2 * (k1 + j2),\n            qy = a2 * (k1 + j2),\n            startAngle = Math.atan2(py - cy, px - cx),\n            endAngle   = Math.atan2(qy - cy, qx - cx);\n\n        this.arc(cx + x1, cy + y1, radius, startAngle, endAngle, b1 * a2 > b2 * a1);\n    }\n\n    this.dirty = this.boundsDirty = true;\n\n    return this;\n};\n\n/**\n * The arc method creates an arc/curve (used to create circles, or parts of circles).\n *\n * @param cx {number} The x-coordinate of the center of the circle\n * @param cy {number} The y-coordinate of the center of the circle\n * @param radius {number} The radius of the circle\n * @param startAngle {number} The starting angle, in radians (0 is at the 3 o'clock position of the arc's circle)\n * @param endAngle {number} The ending angle, in radians\n * @param anticlockwise {boolean} Optional. Specifies whether the drawing should be counterclockwise or clockwise. False is default, and indicates clockwise, while true indicates counter-clockwise.\n * @return {Graphics}\n */\nGraphics.prototype.arc = function(cx, cy, radius, startAngle, endAngle, anticlockwise)\n{\n    anticlockwise = anticlockwise || false;\n\n    if (startAngle === endAngle)\n    {\n        return this;\n    }\n\n    if( !anticlockwise && endAngle <= startAngle )\n    {\n        endAngle += Math.PI * 2;\n    }\n    else if( anticlockwise && startAngle <= endAngle )\n    {\n        startAngle += Math.PI * 2;\n    }\n\n    var sweep = anticlockwise ? (startAngle - endAngle) * -1 : (endAngle - startAngle);\n    var segs =  Math.ceil(Math.abs(sweep) / (Math.PI * 2)) * 40;\n\n    if(sweep === 0)\n    {\n        return this;\n    }\n\n    var startX = cx + Math.cos(startAngle) * radius;\n    var startY = cy + Math.sin(startAngle) * radius;\n\n    if (this.currentPath)\n    {\n        if (anticlockwise && this.filling)\n        {\n            this.currentPath.shape.points.push(cx, cy);\n        }\n        else\n        {\n            this.currentPath.shape.points.push(startX, startY);\n        }\n    }\n    else\n    {\n        if (anticlockwise && this.filling)\n        {\n\n            this.moveTo(cx, cy);\n        }\n        else\n        {\n            this.moveTo(startX, startY);\n        }\n    }\n\n    var points = this.currentPath.shape.points;\n\n    var theta = sweep/(segs*2);\n    var theta2 = theta*2;\n\n    var cTheta = Math.cos(theta);\n    var sTheta = Math.sin(theta);\n\n    var segMinus = segs - 1;\n\n    var remainder = ( segMinus % 1 ) / segMinus;\n\n    for(var i=0; i<=segMinus; i++)\n    {\n        var real =  i + remainder * i;\n\n\n        var angle = ((theta) + startAngle + (theta2 * real));\n\n        var c = Math.cos(angle);\n        var s = -Math.sin(angle);\n\n        points.push(( (cTheta *  c) + (sTheta * s) ) * radius + cx,\n                    ( (cTheta * -s) + (sTheta * c) ) * radius + cy);\n    }\n\n    this.dirty = this.boundsDirty = true;\n\n    return this;\n};\n\n/**\n * Specifies a simple one-color fill that subsequent calls to other Graphics methods\n * (such as lineTo() or drawCircle()) use when drawing.\n *\n * @param color {number} the color of the fill\n * @param alpha {number} the alpha of the fill\n * @return {Graphics}\n */\nGraphics.prototype.beginFill = function (color, alpha)\n{\n    this.filling = true;\n    this.fillColor = color || 0;\n    this.fillAlpha = (alpha === undefined) ? 1 : alpha;\n\n    if (this.currentPath)\n    {\n        if (this.currentPath.shape.points.length <= 2)\n        {\n            this.currentPath.fill = this.filling;\n            this.currentPath.fillColor = this.fillColor;\n            this.currentPath.fillAlpha = this.fillAlpha;\n        }\n    }\n    return this;\n};\n\n/**\n * Applies a fill to the lines and shapes that were added since the last call to the beginFill() method.\n *\n * @return {Graphics}\n */\nGraphics.prototype.endFill = function ()\n{\n    this.filling = false;\n    this.fillColor = null;\n    this.fillAlpha = 1;\n\n    return this;\n};\n\n/**\n *\n * @param x {number} The X coord of the top-left of the rectangle\n * @param y {number} The Y coord of the top-left of the rectangle\n * @param width {number} The width of the rectangle\n * @param height {number} The height of the rectangle\n * @return {Graphics}\n */\nGraphics.prototype.drawRect = function ( x, y, width, height )\n{\n    this.drawShape(new math.Rectangle(x,y, width, height));\n\n    return this;\n};\n\n/**\n *\n * @param x {number} The X coord of the top-left of the rectangle\n * @param y {number} The Y coord of the top-left of the rectangle\n * @param width {number} The width of the rectangle\n * @param height {number} The height of the rectangle\n * @param radius {number} Radius of the rectangle corners\n */\nGraphics.prototype.drawRoundedRect = function ( x, y, width, height, radius )\n{\n    this.drawShape(new math.RoundedRectangle(x, y, width, height, radius));\n\n    return this;\n};\n\n/**\n * Draws a circle.\n *\n * @param x {number} The X coordinate of the center of the circle\n * @param y {number} The Y coordinate of the center of the circle\n * @param radius {number} The radius of the circle\n * @return {Graphics}\n */\nGraphics.prototype.drawCircle = function (x, y, radius)\n{\n    this.drawShape(new math.Circle(x,y, radius));\n\n    return this;\n};\n\n/**\n * Draws an ellipse.\n *\n * @param x {number} The X coordinate of the center of the ellipse\n * @param y {number} The Y coordinate of the center of the ellipse\n * @param width {number} The half width of the ellipse\n * @param height {number} The half height of the ellipse\n * @return {Graphics}\n */\nGraphics.prototype.drawEllipse = function (x, y, width, height)\n{\n    this.drawShape(new math.Ellipse(x, y, width, height));\n\n    return this;\n};\n\n/**\n * Draws a polygon using the given path.\n *\n * @param path {Array} The path data used to construct the polygon.\n * @return {Graphics}\n */\nGraphics.prototype.drawPolygon = function (path)\n{\n    // prevents an argument assignment deopt\n    // see section 3.1: https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#3-managing-arguments\n    var points = path;\n\n    if (!Array.isArray(points))\n    {\n        // prevents an argument leak deopt\n        // see section 3.2: https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#3-managing-arguments\n        points = new Array(arguments.length);\n\n        for (var i = 0; i < points.length; ++i)\n        {\n            points[i] = arguments[i];\n        }\n    }\n\n    this.drawShape(new math.Polygon(points));\n\n    return this;\n};\n\n/**\n * Clears the graphics that were drawn to this Graphics object, and resets fill and line style settings.\n *\n * @return {Graphics}\n */\nGraphics.prototype.clear = function ()\n{\n    this.lineWidth = 0;\n    this.filling = false;\n\n    this.dirty = true;\n    this.clearDirty = true;\n    this.graphicsData = [];\n\n    return this;\n};\n\n/**\n * Useful function that returns a texture of the graphics object that can then be used to create sprites\n * This can be quite useful if your geometry is complicated and needs to be reused multiple times.\n *\n * @param resolution {number} The resolution of the texture being generated\n * @param scaleMode {number} Should be one of the scaleMode consts\n * @return {Texture} a texture of the graphics object\n */\nGraphics.prototype.generateTexture = function (renderer, resolution, scaleMode)\n{\n\n    resolution = resolution || 1;\n\n    var bounds = this.getLocalBounds();\n\n    var canvasBuffer = new CanvasBuffer(bounds.width * resolution, bounds.height * resolution);\n\n    var texture = Texture.fromCanvas(canvasBuffer.canvas, scaleMode);\n    texture.baseTexture.resolution = resolution;\n\n    canvasBuffer.context.scale(resolution, resolution);\n\n    canvasBuffer.context.translate(-bounds.x,-bounds.y);\n\n    CanvasGraphics.renderGraphics(this, canvasBuffer.context);\n\n    return texture;\n};\n\n/**\n * Renders the object using the WebGL renderer\n *\n * @param renderer {WebGLRenderer}\n * @private\n */\nGraphics.prototype._renderWebGL = function (renderer)\n{\n    // if the sprite is not visible or the alpha is 0 then no need to render this element\n\n    // this code may still be needed so leaving for now..\n    //\n    /*\n    if (this._cacheAsBitmap)\n    {\n        if (this.dirty || this.cachedSpriteDirty)\n        {\n            this._generateCachedSprite();\n\n            // we will also need to update the texture on the gpu too!\n            this.updateCachedSpriteTexture();\n\n            this.cachedSpriteDirty = false;\n            this.dirty = false;\n        }\n\n        this._cachedSprite.worldAlpha = this.worldAlpha;\n\n        Sprite.prototype.renderWebGL.call(this._cachedSprite, renderer);\n\n        return;\n    }\n\n    */\n\n    if (this.glDirty)\n    {\n        this.dirty = true;\n        this.glDirty = false;\n    }\n\n    renderer.setObjectRenderer(renderer.plugins.graphics);\n    renderer.plugins.graphics.render(this);\n\n};\n\n/**\n * Renders the object using the Canvas renderer\n *\n * @param renderer {CanvasRenderer}\n * @private\n */\nGraphics.prototype._renderCanvas = function (renderer)\n{\n    if (this.isMask === true)\n    {\n        return;\n    }\n\n    // if the tint has changed, set the graphics object to dirty.\n    if (this._prevTint !== this.tint) {\n        this.dirty = true;\n        this._prevTint = this.tint;\n    }\n\n    // this code may still be needed so leaving for now..\n    //\n    /*\n    if (this._cacheAsBitmap)\n    {\n        if (this.dirty || this.cachedSpriteDirty)\n        {\n            this._generateCachedSprite();\n\n            // we will also need to update the texture\n            this.updateCachedSpriteTexture();\n\n            this.cachedSpriteDirty = false;\n            this.dirty = false;\n        }\n\n        this._cachedSprite.alpha = this.alpha;\n\n        Sprite.prototype._renderCanvas.call(this._cachedSprite, renderer);\n\n        return;\n    }\n    */\n    var context = renderer.context;\n    var transform = this.worldTransform;\n\n    if (this.blendMode !== renderer.currentBlendMode)\n    {\n        renderer.currentBlendMode = this.blendMode;\n        context.globalCompositeOperation = renderer.blendModes[renderer.currentBlendMode];\n    }\n\n    var resolution = renderer.resolution;\n    context.setTransform(\n        transform.a * resolution,\n        transform.b * resolution,\n        transform.c * resolution,\n        transform.d * resolution,\n        transform.tx * resolution,\n        transform.ty * resolution\n    );\n\n    CanvasGraphics.renderGraphics(this, context);\n};\n\n/**\n * Retrieves the bounds of the graphic shape as a rectangle object\n *\n * @return {Rectangle} the rectangular bounding area\n */\nGraphics.prototype.getBounds = function (matrix)\n{\n    if(!this._currentBounds)\n    {\n\n        // return an empty object if the item is a mask!\n        if (!this.renderable)\n        {\n            return math.Rectangle.EMPTY;\n        }\n\n        if (this.boundsDirty)\n        {\n            this.updateLocalBounds();\n\n            this.glDirty = true;\n            this.cachedSpriteDirty = true;\n            this.boundsDirty = false;\n        }\n\n        var bounds = this._localBounds;\n\n        var w0 = bounds.x;\n        var w1 = bounds.width + bounds.x;\n\n        var h0 = bounds.y;\n        var h1 = bounds.height + bounds.y;\n\n        var worldTransform = matrix || this.worldTransform;\n\n        var a = worldTransform.a;\n        var b = worldTransform.b;\n        var c = worldTransform.c;\n        var d = worldTransform.d;\n        var tx = worldTransform.tx;\n        var ty = worldTransform.ty;\n\n        var x1 = a * w1 + c * h1 + tx;\n        var y1 = d * h1 + b * w1 + ty;\n\n        var x2 = a * w0 + c * h1 + tx;\n        var y2 = d * h1 + b * w0 + ty;\n\n        var x3 = a * w0 + c * h0 + tx;\n        var y3 = d * h0 + b * w0 + ty;\n\n        var x4 =  a * w1 + c * h0 + tx;\n        var y4 =  d * h0 + b * w1 + ty;\n\n        var maxX = x1;\n        var maxY = y1;\n\n        var minX = x1;\n        var minY = y1;\n\n        minX = x2 < minX ? x2 : minX;\n        minX = x3 < minX ? x3 : minX;\n        minX = x4 < minX ? x4 : minX;\n\n        minY = y2 < minY ? y2 : minY;\n        minY = y3 < minY ? y3 : minY;\n        minY = y4 < minY ? y4 : minY;\n\n        maxX = x2 > maxX ? x2 : maxX;\n        maxX = x3 > maxX ? x3 : maxX;\n        maxX = x4 > maxX ? x4 : maxX;\n\n        maxY = y2 > maxY ? y2 : maxY;\n        maxY = y3 > maxY ? y3 : maxY;\n        maxY = y4 > maxY ? y4 : maxY;\n\n        this._bounds.x = minX;\n        this._bounds.width = maxX - minX;\n\n        this._bounds.y = minY;\n        this._bounds.height = maxY - minY;\n\n        this._currentBounds = this._bounds;\n    }\n\n    return this._currentBounds;\n};\n\n/**\n* Tests if a point is inside this graphics object\n*\n* @param point {Point} the point to test\n* @return {boolean} the result of the test\n*/\nGraphics.prototype.containsPoint = function( point )\n{\n    this.worldTransform.applyInverse(point,  tempPoint);\n\n    var graphicsData = this.graphicsData;\n\n    for (var i = 0; i < graphicsData.length; i++)\n    {\n        var data = graphicsData[i];\n\n        if (!data.fill)\n        {\n            continue;\n        }\n\n        // only deal with fills..\n        if (data.shape)\n        {\n            if ( data.shape.contains( tempPoint.x, tempPoint.y ) )\n            {\n                return true;\n            }\n        }\n    }\n\n    return false;\n};\n\n/**\n * Update the bounds of the object\n *\n */\nGraphics.prototype.updateLocalBounds = function ()\n{\n    var minX = Infinity;\n    var maxX = -Infinity;\n\n    var minY = Infinity;\n    var maxY = -Infinity;\n\n    if (this.graphicsData.length)\n    {\n        var shape, points, x, y, w, h;\n\n        for (var i = 0; i < this.graphicsData.length; i++)\n        {\n            var data = this.graphicsData[i];\n            var type = data.type;\n            var lineWidth = data.lineWidth;\n            shape = data.shape;\n\n            if (type === CONST.SHAPES.RECT || type === CONST.SHAPES.RREC)\n            {\n                x = shape.x - lineWidth/2;\n                y = shape.y - lineWidth/2;\n                w = shape.width + lineWidth;\n                h = shape.height + lineWidth;\n\n                minX = x < minX ? x : minX;\n                maxX = x + w > maxX ? x + w : maxX;\n\n                minY = y < minY ? y : minY;\n                maxY = y + h > maxY ? y + h : maxY;\n            }\n            else if (type === CONST.SHAPES.CIRC)\n            {\n                x = shape.x;\n                y = shape.y;\n                w = shape.radius + lineWidth/2;\n                h = shape.radius + lineWidth/2;\n\n                minX = x - w < minX ? x - w : minX;\n                maxX = x + w > maxX ? x + w : maxX;\n\n                minY = y - h < minY ? y - h : minY;\n                maxY = y + h > maxY ? y + h : maxY;\n            }\n            else if (type === CONST.SHAPES.ELIP)\n            {\n                x = shape.x;\n                y = shape.y;\n                w = shape.width + lineWidth/2;\n                h = shape.height + lineWidth/2;\n\n                minX = x - w < minX ? x - w : minX;\n                maxX = x + w > maxX ? x + w : maxX;\n\n                minY = y - h < minY ? y - h : minY;\n                maxY = y + h > maxY ? y + h : maxY;\n            }\n            else\n            {\n                // POLY\n                points = shape.points;\n\n                for (var j = 0; j < points.length; j += 2)\n                {\n                    x = points[j];\n                    y = points[j+1];\n\n                    minX = x-lineWidth < minX ? x-lineWidth : minX;\n                    maxX = x+lineWidth > maxX ? x+lineWidth : maxX;\n\n                    minY = y-lineWidth < minY ? y-lineWidth : minY;\n                    maxY = y+lineWidth > maxY ? y+lineWidth : maxY;\n                }\n            }\n        }\n    }\n    else\n    {\n        minX = 0;\n        maxX = 0;\n        minY = 0;\n        maxY = 0;\n    }\n\n    var padding = this.boundsPadding;\n\n    this._localBounds.x = minX - padding;\n    this._localBounds.width = (maxX - minX) + padding * 2;\n\n    this._localBounds.y = minY - padding;\n    this._localBounds.height = (maxY - minY) + padding * 2;\n};\n\n/**\n * Generates the cached sprite when the sprite has cacheAsBitmap = true\n *\n * @private\n */\n/*\nGraphics.prototype._generateCachedSprite = function ()\n{\n    var bounds = this.getLocalBounds();\n\n    if (!this._cachedSprite)\n    {\n        var canvasBuffer = new CanvasBuffer(bounds.width, bounds.height);\n        var texture = Texture.fromCanvas(canvasBuffer.canvas);\n\n        this._cachedSprite = new Sprite(texture);\n        this._cachedSprite.buffer = canvasBuffer;\n\n        this._cachedSprite.worldTransform = this.worldTransform;\n    }\n    else\n    {\n        this._cachedSprite.buffer.resize(bounds.width, bounds.height);\n    }\n\n    // leverage the anchor to account for the offset of the element\n    this._cachedSprite.anchor.x = -( bounds.x / bounds.width );\n    this._cachedSprite.anchor.y = -( bounds.y / bounds.height );\n\n    // this._cachedSprite.buffer.context.save();\n    this._cachedSprite.buffer.context.translate(-bounds.x,-bounds.y);\n\n    // make sure we set the alpha of the graphics to 1 for the render..\n    this.worldAlpha = 1;\n\n    // now render the graphic..\n    CanvasGraphics.renderGraphics(this, this._cachedSprite.buffer.context);\n\n    this._cachedSprite.alpha = this.alpha;\n};\n*/\n/**\n * Updates texture size based on canvas size\n *\n * @private\n */\n/*\nGraphics.prototype.updateCachedSpriteTexture = function ()\n{\n    var cachedSprite = this._cachedSprite;\n    var texture = cachedSprite.texture;\n    var canvas = cachedSprite.buffer.canvas;\n\n    texture.baseTexture.width = canvas.width;\n    texture.baseTexture.height = canvas.height;\n    texture.crop.width = texture.frame.width = canvas.width;\n    texture.crop.height = texture.frame.height = canvas.height;\n\n    cachedSprite._width = canvas.width;\n    cachedSprite._height = canvas.height;\n\n    // update the dirty base textures\n    texture.baseTexture.dirty();\n};*/\n\n/**\n * Destroys a previous cached sprite.\n *\n */\n/*\nGraphics.prototype.destroyCachedSprite = function ()\n{\n    this._cachedSprite.texture.destroy(true);\n\n    // let the gc collect the unused sprite\n    // TODO could be object pooled!\n    this._cachedSprite = null;\n};*/\n\n/**\n * Draws the given shape to this Graphics object. Can be any of Circle, Rectangle, Ellipse, Line or Polygon.\n *\n * @param shape {Circle|Rectangle|Ellipse|Line|Polygon} The shape object to draw.\n * @return {GraphicsData} The generated GraphicsData object.\n */\nGraphics.prototype.drawShape = function (shape)\n{\n    if (this.currentPath)\n    {\n        // check current path!\n        if (this.currentPath.shape.points.length <= 2)\n        {\n            this.graphicsData.pop();\n        }\n    }\n\n    this.currentPath = null;\n\n    var data = new GraphicsData(this.lineWidth, this.lineColor, this.lineAlpha, this.fillColor, this.fillAlpha, this.filling, shape);\n\n    this.graphicsData.push(data);\n\n    if (data.type === CONST.SHAPES.POLY)\n    {\n        data.shape.closed = data.shape.closed || this.filling;\n        this.currentPath = data;\n    }\n\n    this.dirty = this.boundsDirty = true;\n\n    return data;\n};\n\nGraphics.prototype.destroy = function () {\n    Container.prototype.destroy.apply(this, arguments);\n\n    // destroy each of the GraphicsData objects\n    for (var i = 0; i < this.graphicsData.length; ++i) {\n        this.graphicsData[i].destroy();\n    }\n\n    // for each webgl data entry, destroy the WebGLGraphicsData\n    for (var id in this._webgl) {\n        for (var j = 0; j < this._webgl[id].data.length; ++j) {\n            this._webgl[id].data[j].destroy();\n        }\n    }\n\n    this.graphicsData = null;\n\n    this.currentPath = null;\n    this._webgl = null;\n    this._localBounds = null;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}