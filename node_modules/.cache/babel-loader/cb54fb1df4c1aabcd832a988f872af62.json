{"ast":null,"code":"var utils = require('../utils'),\n    CONST = require('../const'),\n    EventEmitter = require('eventemitter3');\n/**\n * A texture stores the information that represents an image. All textures have a base texture.\n *\n * @class\n * @memberof PIXI\n * @param source {Image|Canvas} the source object of the texture.\n * @param [scaleMode=scaleModes.DEFAULT] {number} See {@link SCALE_MODES} for possible values\n * @param resolution {number} the resolution of the texture for devices with different pixel ratios\n */\n\n\nfunction BaseTexture(source, scaleMode, resolution) {\n  EventEmitter.call(this);\n  this.uid = utils.uid();\n  /**\n   * The Resolution of the texture.\n   *\n   * @member {number}\n   */\n\n  this.resolution = resolution || 1;\n  /**\n   * The width of the base texture set when the image has loaded\n   *\n   * @member {number}\n   * @readOnly\n   */\n\n  this.width = 100;\n  /**\n   * The height of the base texture set when the image has loaded\n   *\n   * @member {number}\n   * @readOnly\n   */\n\n  this.height = 100; // TODO docs\n  // used to store the actual dimensions of the source\n\n  /**\n   * Used to store the actual width of the source of this texture\n   *\n   * @member {number}\n   * @readOnly\n   */\n\n  this.realWidth = 100;\n  /**\n   * Used to store the actual height of the source of this texture\n   *\n   * @member {number}\n   * @readOnly\n   */\n\n  this.realHeight = 100;\n  /**\n   * The scale mode to apply when scaling this texture\n   *\n   * @member {{number}}\n   * @default scaleModes.LINEAR\n   */\n\n  this.scaleMode = scaleMode || CONST.SCALE_MODES.DEFAULT;\n  /**\n   * Set to true once the base texture has successfully loaded.\n   *\n   * This is never true if the underlying source fails to load or has no texture data.\n   *\n   * @member {boolean}\n   * @readOnly\n   */\n\n  this.hasLoaded = false;\n  /**\n   * Set to true if the source is currently loading.\n   *\n   * If an Image source is loading the 'loaded' or 'error' event will be\n   * dispatched when the operation ends. An underyling source that is\n   * immediately-available bypasses loading entirely.\n   *\n   * @member {boolean}\n   * @readonly\n   */\n\n  this.isLoading = false;\n  /**\n   * The image source that is used to create the texture.\n   *\n   * TODO: Make this a setter that calls loadSource();\n   *\n   * @member {Image|Canvas}\n   * @readonly\n   */\n\n  this.source = null; // set in loadSource, if at all\n\n  /**\n   * Controls if RGB channels should be pre-multiplied by Alpha  (WebGL only)\n   *\n   * @member {boolean}\n   * @default true\n   */\n\n  this.premultipliedAlpha = true;\n  /**\n   * @member {string}\n   */\n\n  this.imageUrl = null;\n  /**\n   * Wether or not the texture is a power of two, try to use power of two textures as much as you can\n   * @member {boolean}\n   * @private\n   */\n\n  this.isPowerOfTwo = false; // used for webGL\n\n  /**\n   *\n   * Set this to true if a mipmap of this texture needs to be generated. This value needs to be set before the texture is used\n   * Also the texture must be a power of two size to work\n   *\n   * @member {boolean}\n   */\n\n  this.mipmap = false;\n  /**\n   * A map of renderer IDs to webgl textures\n   *\n   * @member {object<number, WebGLTexture>}\n   * @private\n   */\n\n  this._glTextures = []; // if no source passed don't try to load\n\n  if (source) {\n    this.loadSource(source);\n  }\n  /**\n   * Fired when a not-immediately-available source finishes loading.\n   *\n   * @event loaded\n   * @memberof PIXI.BaseTexture#\n   * @protected\n   */\n\n  /**\n   * Fired when a not-immediately-available source fails to load.\n   *\n   * @event error\n   * @memberof PIXI.BaseTexture#\n   * @protected\n   */\n\n}\n\nBaseTexture.prototype = Object.create(EventEmitter.prototype);\nBaseTexture.prototype.constructor = BaseTexture;\nmodule.exports = BaseTexture;\n/**\n * Updates the texture on all the webgl renderers, this also assumes the src has changed.\n *\n * @fires update\n */\n\nBaseTexture.prototype.update = function () {\n  this.realWidth = this.source.naturalWidth || this.source.width;\n  this.realHeight = this.source.naturalHeight || this.source.height;\n  this.width = this.realWidth / this.resolution;\n  this.height = this.realHeight / this.resolution;\n  this.isPowerOfTwo = utils.isPowerOfTwo(this.realWidth, this.realHeight);\n  this.emit('update', this);\n};\n/**\n * Load a source.\n *\n * If the source is not-immediately-available, such as an image that needs to be\n * downloaded, then the 'loaded' or 'error' event will be dispatched in the future\n * and `hasLoaded` will remain false after this call.\n *\n * The logic state after calling `loadSource` directly or indirectly (eg. `fromImage`, `new BaseTexture`) is:\n *\n *     if (texture.hasLoaded)\n {\n *        // texture ready for use\n *     } else if (texture.isLoading)\n {\n *        // listen to 'loaded' and/or 'error' events on texture\n *     } else {\n *        // not loading, not going to load UNLESS the source is reloaded\n *        // (it may still make sense to listen to the events)\n *     }\n *\n * @protected\n * @param source {Image|Canvas} the source object of the texture.\n */\n\n\nBaseTexture.prototype.loadSource = function (source) {\n  var wasLoading = this.isLoading;\n  this.hasLoaded = false;\n  this.isLoading = false;\n\n  if (wasLoading && this.source) {\n    this.source.onload = null;\n    this.source.onerror = null;\n  }\n\n  this.source = source; // Apply source if loaded. Otherwise setup appropriate loading monitors.\n\n  if ((this.source.complete || this.source.getContext) && this.source.width && this.source.height) {\n    this._sourceLoaded();\n  } else if (!source.getContext) {\n    // Image fail / not ready\n    this.isLoading = true;\n    var scope = this;\n\n    source.onload = function () {\n      source.onload = null;\n      source.onerror = null;\n\n      if (!scope.isLoading) {\n        return;\n      }\n\n      scope.isLoading = false;\n\n      scope._sourceLoaded();\n\n      scope.emit('loaded', scope);\n    };\n\n    source.onerror = function () {\n      source.onload = null;\n      source.onerror = null;\n\n      if (!scope.isLoading) {\n        return;\n      }\n\n      scope.isLoading = false;\n      scope.emit('error', scope);\n    }; // Per http://www.w3.org/TR/html5/embedded-content-0.html#the-img-element\n    //   \"The value of `complete` can thus change while a script is executing.\"\n    // So complete needs to be re-checked after the callbacks have been added..\n    // NOTE: complete will be true if the image has no src so best to check if the src is set.\n\n\n    if (source.complete && source.src) {\n      this.isLoading = false; // ..and if we're complete now, no need for callbacks\n\n      source.onload = null;\n      source.onerror = null;\n\n      if (source.width && source.height) {\n        this._sourceLoaded(); // If any previous subscribers possible\n\n\n        if (wasLoading) {\n          this.emit('loaded', this);\n        }\n      } else {\n        // If any previous subscribers possible\n        if (wasLoading) {\n          this.emit('error', this);\n        }\n      }\n    }\n  }\n};\n/**\n * Used internally to update the width, height, and some other tracking vars once\n * a source has successfully loaded.\n *\n * @private\n */\n\n\nBaseTexture.prototype._sourceLoaded = function () {\n  this.hasLoaded = true;\n  this.update();\n};\n/**\n * Destroys this base texture\n *\n */\n\n\nBaseTexture.prototype.destroy = function () {\n  if (this.imageUrl) {\n    delete utils.BaseTextureCache[this.imageUrl];\n    delete utils.TextureCache[this.imageUrl];\n    this.imageUrl = null;\n\n    if (!navigator.isCocoonJS) {\n      this.source.src = '';\n    }\n  } else if (this.source && this.source._pixiId) {\n    delete utils.BaseTextureCache[this.source._pixiId];\n  }\n\n  this.source = null;\n  this.dispose();\n};\n/**\n * Frees the texture from WebGL memory without destroying this texture object.\n * This means you can still use the texture later which will upload it to GPU\n * memory again.\n *\n */\n\n\nBaseTexture.prototype.dispose = function () {\n  this.emit('dispose', this);\n  this._glTextures.length = 0;\n};\n/**\n * Changes the source image of the texture.\n * The original source must be an Image element.\n *\n * @param newSrc {string} the path of the image\n */\n\n\nBaseTexture.prototype.updateSourceImage = function (newSrc) {\n  this.source.src = newSrc;\n  this.loadSource(this.source);\n};\n/**\n * Helper function that creates a base texture from the given image url.\n * If the image is not in the base texture cache it will be created and loaded.\n *\n * @static\n * @param imageUrl {string} The image url of the texture\n * @param [crossorigin=(auto)] {boolean} Should use anonymous CORS? Defaults to true if the URL is not a data-URI.\n * @param [scaleMode=scaleModes.DEFAULT] {number} See {@link SCALE_MODES} for possible values\n * @return BaseTexture\n */\n\n\nBaseTexture.fromImage = function (imageUrl, crossorigin, scaleMode) {\n  var baseTexture = utils.BaseTextureCache[imageUrl];\n\n  if (crossorigin === undefined && imageUrl.indexOf('data:') !== 0) {\n    crossorigin = true;\n  }\n\n  if (!baseTexture) {\n    // new Image() breaks tex loading in some versions of Chrome.\n    // See https://code.google.com/p/chromium/issues/detail?id=238071\n    var image = new Image(); //document.createElement('img');\n\n    if (crossorigin) {\n      image.crossOrigin = '';\n    }\n\n    baseTexture = new BaseTexture(image, scaleMode);\n    baseTexture.imageUrl = imageUrl;\n    image.src = imageUrl;\n    utils.BaseTextureCache[imageUrl] = baseTexture; // if there is an @2x at the end of the url we are going to assume its a highres image\n\n    baseTexture.resolution = utils.getResolutionOfUrl(imageUrl);\n  }\n\n  return baseTexture;\n};\n/**\n * Helper function that creates a base texture from the given canvas element.\n *\n * @static\n * @param canvas {Canvas} The canvas element source of the texture\n * @param scaleMode {number} See {{#crossLink \"PIXI/scaleModes:property\"}}scaleModes{{/crossLink}} for possible values\n * @return BaseTexture\n */\n\n\nBaseTexture.fromCanvas = function (canvas, scaleMode) {\n  if (!canvas._pixiId) {\n    canvas._pixiId = 'canvas_' + utils.uid();\n  }\n\n  var baseTexture = utils.BaseTextureCache[canvas._pixiId];\n\n  if (!baseTexture) {\n    baseTexture = new BaseTexture(canvas, scaleMode);\n    utils.BaseTextureCache[canvas._pixiId] = baseTexture;\n  }\n\n  return baseTexture;\n};","map":{"version":3,"names":["utils","require","CONST","EventEmitter","BaseTexture","source","scaleMode","resolution","call","uid","width","height","realWidth","realHeight","SCALE_MODES","DEFAULT","hasLoaded","isLoading","premultipliedAlpha","imageUrl","isPowerOfTwo","mipmap","_glTextures","loadSource","prototype","Object","create","constructor","module","exports","update","naturalWidth","naturalHeight","emit","wasLoading","onload","onerror","complete","getContext","_sourceLoaded","scope","src","destroy","BaseTextureCache","TextureCache","navigator","isCocoonJS","_pixiId","dispose","length","updateSourceImage","newSrc","fromImage","crossorigin","baseTexture","undefined","indexOf","image","Image","crossOrigin","getResolutionOfUrl","fromCanvas","canvas"],"sources":["/home/reyden-martin/Documents/Tech2/HUB/Sony CSL/SONY-CSL-PROJECT/node_modules/react-piano-roll/node_modules/pixi.js/src/core/textures/BaseTexture.js"],"sourcesContent":["var utils = require('../utils'),\n    CONST = require('../const'),\n    EventEmitter = require('eventemitter3');\n\n/**\n * A texture stores the information that represents an image. All textures have a base texture.\n *\n * @class\n * @memberof PIXI\n * @param source {Image|Canvas} the source object of the texture.\n * @param [scaleMode=scaleModes.DEFAULT] {number} See {@link SCALE_MODES} for possible values\n * @param resolution {number} the resolution of the texture for devices with different pixel ratios\n */\nfunction BaseTexture(source, scaleMode, resolution)\n{\n    EventEmitter.call(this);\n\n    this.uid = utils.uid();\n\n    /**\n     * The Resolution of the texture.\n     *\n     * @member {number}\n     */\n    this.resolution = resolution || 1;\n\n    /**\n     * The width of the base texture set when the image has loaded\n     *\n     * @member {number}\n     * @readOnly\n     */\n    this.width = 100;\n\n    /**\n     * The height of the base texture set when the image has loaded\n     *\n     * @member {number}\n     * @readOnly\n     */\n    this.height = 100;\n\n    // TODO docs\n    // used to store the actual dimensions of the source\n    /**\n     * Used to store the actual width of the source of this texture\n     *\n     * @member {number}\n     * @readOnly\n     */\n    this.realWidth = 100;\n    /**\n     * Used to store the actual height of the source of this texture\n     *\n     * @member {number}\n     * @readOnly\n     */\n    this.realHeight = 100;\n\n    /**\n     * The scale mode to apply when scaling this texture\n     *\n     * @member {{number}}\n     * @default scaleModes.LINEAR\n     */\n    this.scaleMode = scaleMode || CONST.SCALE_MODES.DEFAULT;\n\n    /**\n     * Set to true once the base texture has successfully loaded.\n     *\n     * This is never true if the underlying source fails to load or has no texture data.\n     *\n     * @member {boolean}\n     * @readOnly\n     */\n    this.hasLoaded = false;\n\n    /**\n     * Set to true if the source is currently loading.\n     *\n     * If an Image source is loading the 'loaded' or 'error' event will be\n     * dispatched when the operation ends. An underyling source that is\n     * immediately-available bypasses loading entirely.\n     *\n     * @member {boolean}\n     * @readonly\n     */\n    this.isLoading = false;\n\n    /**\n     * The image source that is used to create the texture.\n     *\n     * TODO: Make this a setter that calls loadSource();\n     *\n     * @member {Image|Canvas}\n     * @readonly\n     */\n    this.source = null; // set in loadSource, if at all\n\n    /**\n     * Controls if RGB channels should be pre-multiplied by Alpha  (WebGL only)\n     *\n     * @member {boolean}\n     * @default true\n     */\n    this.premultipliedAlpha = true;\n\n    /**\n     * @member {string}\n     */\n    this.imageUrl = null;\n\n    /**\n     * Wether or not the texture is a power of two, try to use power of two textures as much as you can\n     * @member {boolean}\n     * @private\n     */\n    this.isPowerOfTwo = false;\n\n    // used for webGL\n\n    /**\n     *\n     * Set this to true if a mipmap of this texture needs to be generated. This value needs to be set before the texture is used\n     * Also the texture must be a power of two size to work\n     *\n     * @member {boolean}\n     */\n    this.mipmap = false;\n\n    /**\n     * A map of renderer IDs to webgl textures\n     *\n     * @member {object<number, WebGLTexture>}\n     * @private\n     */\n    this._glTextures = [];\n\n    // if no source passed don't try to load\n    if (source)\n    {\n        this.loadSource(source);\n    }\n\n    /**\n     * Fired when a not-immediately-available source finishes loading.\n     *\n     * @event loaded\n     * @memberof PIXI.BaseTexture#\n     * @protected\n     */\n\n    /**\n     * Fired when a not-immediately-available source fails to load.\n     *\n     * @event error\n     * @memberof PIXI.BaseTexture#\n     * @protected\n     */\n}\n\nBaseTexture.prototype = Object.create(EventEmitter.prototype);\nBaseTexture.prototype.constructor = BaseTexture;\nmodule.exports = BaseTexture;\n\n/**\n * Updates the texture on all the webgl renderers, this also assumes the src has changed.\n *\n * @fires update\n */\nBaseTexture.prototype.update = function ()\n{\n    this.realWidth = this.source.naturalWidth || this.source.width;\n    this.realHeight = this.source.naturalHeight || this.source.height;\n\n    this.width = this.realWidth / this.resolution;\n    this.height = this.realHeight / this.resolution;\n\n    this.isPowerOfTwo = utils.isPowerOfTwo(this.realWidth, this.realHeight);\n\n    this.emit('update', this);\n};\n\n/**\n * Load a source.\n *\n * If the source is not-immediately-available, such as an image that needs to be\n * downloaded, then the 'loaded' or 'error' event will be dispatched in the future\n * and `hasLoaded` will remain false after this call.\n *\n * The logic state after calling `loadSource` directly or indirectly (eg. `fromImage`, `new BaseTexture`) is:\n *\n *     if (texture.hasLoaded)\n {\n *        // texture ready for use\n *     } else if (texture.isLoading)\n {\n *        // listen to 'loaded' and/or 'error' events on texture\n *     } else {\n *        // not loading, not going to load UNLESS the source is reloaded\n *        // (it may still make sense to listen to the events)\n *     }\n *\n * @protected\n * @param source {Image|Canvas} the source object of the texture.\n */\nBaseTexture.prototype.loadSource = function (source)\n{\n    var wasLoading = this.isLoading;\n    this.hasLoaded = false;\n    this.isLoading = false;\n\n    if (wasLoading && this.source)\n    {\n        this.source.onload = null;\n        this.source.onerror = null;\n    }\n\n    this.source = source;\n\n    // Apply source if loaded. Otherwise setup appropriate loading monitors.\n    if ((this.source.complete || this.source.getContext) && this.source.width && this.source.height)\n    {\n        this._sourceLoaded();\n    }\n    else if (!source.getContext)\n    {\n\n        // Image fail / not ready\n        this.isLoading = true;\n\n        var scope = this;\n\n        source.onload = function ()\n        {\n            source.onload = null;\n            source.onerror = null;\n\n            if (!scope.isLoading)\n            {\n                return;\n            }\n\n            scope.isLoading = false;\n            scope._sourceLoaded();\n\n            scope.emit('loaded', scope);\n        };\n\n        source.onerror = function ()\n        {\n            source.onload = null;\n            source.onerror = null;\n\n            if (!scope.isLoading)\n            {\n                return;\n            }\n\n            scope.isLoading = false;\n            scope.emit('error', scope);\n        };\n\n        // Per http://www.w3.org/TR/html5/embedded-content-0.html#the-img-element\n        //   \"The value of `complete` can thus change while a script is executing.\"\n        // So complete needs to be re-checked after the callbacks have been added..\n        // NOTE: complete will be true if the image has no src so best to check if the src is set.\n        if (source.complete && source.src)\n        {\n            this.isLoading = false;\n\n            // ..and if we're complete now, no need for callbacks\n            source.onload = null;\n            source.onerror = null;\n\n            if (source.width && source.height)\n            {\n                this._sourceLoaded();\n\n                // If any previous subscribers possible\n                if (wasLoading)\n                {\n                    this.emit('loaded', this);\n                }\n            }\n            else\n            {\n                // If any previous subscribers possible\n                if (wasLoading)\n                {\n                    this.emit('error', this);\n                }\n            }\n        }\n    }\n};\n\n/**\n * Used internally to update the width, height, and some other tracking vars once\n * a source has successfully loaded.\n *\n * @private\n */\nBaseTexture.prototype._sourceLoaded = function ()\n{\n    this.hasLoaded = true;\n    this.update();\n};\n\n/**\n * Destroys this base texture\n *\n */\nBaseTexture.prototype.destroy = function ()\n{\n    if (this.imageUrl)\n    {\n        delete utils.BaseTextureCache[this.imageUrl];\n        delete utils.TextureCache[this.imageUrl];\n\n        this.imageUrl = null;\n\n        if (!navigator.isCocoonJS)\n        {\n            this.source.src = '';\n        }\n    }\n    else if (this.source && this.source._pixiId)\n    {\n        delete utils.BaseTextureCache[this.source._pixiId];\n    }\n\n    this.source = null;\n\n    this.dispose();\n};\n\n/**\n * Frees the texture from WebGL memory without destroying this texture object.\n * This means you can still use the texture later which will upload it to GPU\n * memory again.\n *\n */\nBaseTexture.prototype.dispose = function ()\n{\n    this.emit('dispose', this);\n\n    this._glTextures.length = 0;\n};\n\n/**\n * Changes the source image of the texture.\n * The original source must be an Image element.\n *\n * @param newSrc {string} the path of the image\n */\nBaseTexture.prototype.updateSourceImage = function (newSrc)\n{\n    this.source.src = newSrc;\n\n    this.loadSource(this.source);\n};\n\n/**\n * Helper function that creates a base texture from the given image url.\n * If the image is not in the base texture cache it will be created and loaded.\n *\n * @static\n * @param imageUrl {string} The image url of the texture\n * @param [crossorigin=(auto)] {boolean} Should use anonymous CORS? Defaults to true if the URL is not a data-URI.\n * @param [scaleMode=scaleModes.DEFAULT] {number} See {@link SCALE_MODES} for possible values\n * @return BaseTexture\n */\nBaseTexture.fromImage = function (imageUrl, crossorigin, scaleMode)\n{\n    var baseTexture = utils.BaseTextureCache[imageUrl];\n\n    if (crossorigin === undefined && imageUrl.indexOf('data:') !== 0)\n    {\n        crossorigin = true;\n    }\n\n    if (!baseTexture)\n    {\n        // new Image() breaks tex loading in some versions of Chrome.\n        // See https://code.google.com/p/chromium/issues/detail?id=238071\n        var image = new Image();//document.createElement('img');\n        if (crossorigin)\n        {\n            image.crossOrigin = '';\n        }\n\n        baseTexture = new BaseTexture(image, scaleMode);\n        baseTexture.imageUrl = imageUrl;\n\n        image.src = imageUrl;\n\n        utils.BaseTextureCache[imageUrl] = baseTexture;\n\n        // if there is an @2x at the end of the url we are going to assume its a highres image\n        baseTexture.resolution = utils.getResolutionOfUrl(imageUrl);\n    }\n\n    return baseTexture;\n};\n\n/**\n * Helper function that creates a base texture from the given canvas element.\n *\n * @static\n * @param canvas {Canvas} The canvas element source of the texture\n * @param scaleMode {number} See {{#crossLink \"PIXI/scaleModes:property\"}}scaleModes{{/crossLink}} for possible values\n * @return BaseTexture\n */\nBaseTexture.fromCanvas = function (canvas, scaleMode)\n{\n    if (!canvas._pixiId)\n    {\n        canvas._pixiId = 'canvas_' + utils.uid();\n    }\n\n    var baseTexture = utils.BaseTextureCache[canvas._pixiId];\n\n    if (!baseTexture)\n    {\n        baseTexture = new BaseTexture(canvas, scaleMode);\n        utils.BaseTextureCache[canvas._pixiId] = baseTexture;\n    }\n\n    return baseTexture;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}