{"ast":null,"code":"'use strict';\n/**\n * Smaller version of the async library constructs.\n *\n */\n\nmodule.exports = {\n  eachSeries: asyncEachSeries,\n  queue: asyncQueue\n};\n\nfunction _noop() {\n  /* empty */\n}\n/**\n * Iterates an array in series.\n *\n * @param {*[]} array - Array to iterate.\n * @param {function} iterator - Function to call for each element.\n * @param {function} callback - Function to call when done, or on error.\n */\n\n\nfunction asyncEachSeries(array, iterator, callback) {\n  var i = 0;\n  var len = array.length;\n\n  (function next(err) {\n    if (err || i === len) {\n      if (callback) {\n        callback(err);\n      }\n\n      return;\n    }\n\n    iterator(array[i++], next);\n  })();\n}\n/**\n * Ensures a function is only called once.\n *\n * @param {function} fn - The function to wrap.\n * @return {function} The wrapping function.\n */\n\n\nfunction onlyOnce(fn) {\n  return function onceWrapper() {\n    if (fn === null) {\n      throw new Error('Callback was already called.');\n    }\n\n    var callFn = fn;\n    fn = null;\n    callFn.apply(this, arguments);\n  };\n}\n/**\n * Async queue implementation,\n *\n * @param {function} worker - The worker function to call for each task.\n * @param {number} concurrency - How many workers to run in parrallel.\n * @return {*} The async queue object.\n */\n\n\nfunction asyncQueue(worker, concurrency) {\n  if (concurrency == null) {\n    // eslint-disable-line no-eq-null,eqeqeq\n    concurrency = 1;\n  } else if (concurrency === 0) {\n    throw new Error('Concurrency must not be zero');\n  }\n\n  var workers = 0;\n  var q = {\n    _tasks: [],\n    concurrency: concurrency,\n    saturated: _noop,\n    unsaturated: _noop,\n    buffer: concurrency / 4,\n    empty: _noop,\n    drain: _noop,\n    error: _noop,\n    started: false,\n    paused: false,\n    push: function (data, callback) {\n      _insert(data, false, callback);\n    },\n    kill: function () {\n      q.drain = _noop;\n      q._tasks = [];\n    },\n    unshift: function (data, callback) {\n      _insert(data, true, callback);\n    },\n    process: function () {\n      while (!q.paused && workers < q.concurrency && q._tasks.length) {\n        var task = q._tasks.shift();\n\n        if (q._tasks.length === 0) {\n          q.empty();\n        }\n\n        workers += 1;\n\n        if (workers === q.concurrency) {\n          q.saturated();\n        }\n\n        worker(task.data, onlyOnce(_next(task)));\n      }\n    },\n    length: function () {\n      return q._tasks.length;\n    },\n    running: function () {\n      return workers;\n    },\n    idle: function () {\n      return q._tasks.length + workers === 0;\n    },\n    pause: function () {\n      if (q.paused === true) {\n        return;\n      }\n\n      q.paused = true;\n    },\n    resume: function () {\n      if (q.paused === false) {\n        return;\n      }\n\n      q.paused = false; // Need to call q.process once per concurrent\n      // worker to preserve full concurrency after pause\n\n      for (var w = 1; w <= q.concurrency; w++) {\n        q.process();\n      }\n    }\n  };\n\n  function _insert(data, insertAtFront, callback) {\n    if (callback != null && typeof callback !== 'function') {\n      // eslint-disable-line no-eq-null,eqeqeq\n      throw new Error('task callback must be a function');\n    }\n\n    q.started = true;\n\n    if (data == null && q.idle()) {\n      // eslint-disable-line no-eq-null,eqeqeq\n      // call drain immediately if there are no tasks\n      setTimeout(function () {\n        q.drain();\n      }, 1);\n      return;\n    }\n\n    var item = {\n      data: data,\n      callback: typeof callback === 'function' ? callback : _noop\n    };\n\n    if (insertAtFront) {\n      q._tasks.unshift(item);\n    } else {\n      q._tasks.push(item);\n    }\n\n    setTimeout(function () {\n      q.process();\n    }, 1);\n  }\n\n  function _next(task) {\n    return function () {\n      workers -= 1;\n      task.callback.apply(task, arguments);\n\n      if (arguments[0] != null) {\n        // eslint-disable-line no-eq-null,eqeqeq\n        q.error(arguments[0], task.data);\n      }\n\n      if (workers <= q.concurrency - q.buffer) {\n        q.unsaturated();\n      }\n\n      if (q.idle()) {\n        q.drain();\n      }\n\n      q.process();\n    };\n  }\n\n  return q;\n}","map":{"version":3,"names":["module","exports","eachSeries","asyncEachSeries","queue","asyncQueue","_noop","array","iterator","callback","i","len","length","next","err","onlyOnce","fn","onceWrapper","Error","callFn","apply","arguments","worker","concurrency","workers","q","_tasks","saturated","unsaturated","buffer","empty","drain","error","started","paused","push","data","_insert","kill","unshift","process","task","shift","_next","running","idle","pause","resume","w","insertAtFront","setTimeout","item"],"sources":["/home/reyden-martin/Documents/Tech2/HUB/Sony CSL/SONY-CSL-PROJECT/node_modules/resource-loader/src/async.js"],"sourcesContent":["'use strict';\n\n/**\n * Smaller version of the async library constructs.\n *\n */\n\nmodule.exports = {\n    eachSeries: asyncEachSeries,\n    queue: asyncQueue\n};\n\nfunction _noop() { /* empty */ }\n\n/**\n * Iterates an array in series.\n *\n * @param {*[]} array - Array to iterate.\n * @param {function} iterator - Function to call for each element.\n * @param {function} callback - Function to call when done, or on error.\n */\nfunction asyncEachSeries(array, iterator, callback) {\n    var i = 0;\n    var len = array.length;\n\n    (function next(err) {\n        if (err || i === len) {\n            if (callback) {\n                callback(err);\n            }\n\n            return;\n        }\n\n        iterator(array[i++], next);\n    })();\n}\n\n/**\n * Ensures a function is only called once.\n *\n * @param {function} fn - The function to wrap.\n * @return {function} The wrapping function.\n */\nfunction onlyOnce(fn) {\n    return function onceWrapper() {\n        if (fn === null) {\n            throw new Error('Callback was already called.');\n        }\n\n        var callFn = fn;\n\n        fn = null;\n        callFn.apply(this, arguments);\n    };\n}\n\n/**\n * Async queue implementation,\n *\n * @param {function} worker - The worker function to call for each task.\n * @param {number} concurrency - How many workers to run in parrallel.\n * @return {*} The async queue object.\n */\nfunction asyncQueue(worker, concurrency) {\n    if (concurrency == null) { // eslint-disable-line no-eq-null,eqeqeq\n        concurrency = 1;\n    }\n    else if (concurrency === 0) {\n        throw new Error('Concurrency must not be zero');\n    }\n\n    var workers = 0;\n    var q = {\n        _tasks: [],\n        concurrency: concurrency,\n        saturated: _noop,\n        unsaturated: _noop,\n        buffer: concurrency / 4,\n        empty: _noop,\n        drain: _noop,\n        error: _noop,\n        started: false,\n        paused: false,\n        push: function (data, callback) {\n            _insert(data, false, callback);\n        },\n        kill: function () {\n            q.drain = _noop;\n            q._tasks = [];\n        },\n        unshift: function (data, callback) {\n            _insert(data, true, callback);\n        },\n        process: function () {\n            while (!q.paused && workers < q.concurrency && q._tasks.length) {\n                var task = q._tasks.shift();\n\n                if (q._tasks.length === 0) {\n                    q.empty();\n                }\n\n                workers += 1;\n\n                if (workers === q.concurrency) {\n                    q.saturated();\n                }\n\n                worker(task.data, onlyOnce(_next(task)));\n            }\n        },\n        length: function () {\n            return q._tasks.length;\n        },\n        running: function () {\n            return workers;\n        },\n        idle: function () {\n            return q._tasks.length + workers === 0;\n        },\n        pause: function () {\n            if (q.paused === true) {\n                return;\n            }\n\n            q.paused = true;\n        },\n        resume: function () {\n            if (q.paused === false) {\n                return;\n            }\n\n            q.paused = false;\n\n            // Need to call q.process once per concurrent\n            // worker to preserve full concurrency after pause\n            for (var w = 1; w <= q.concurrency; w++) {\n                q.process();\n            }\n        }\n    };\n\n    function _insert(data, insertAtFront, callback) {\n        if (callback != null && typeof callback !== 'function') { // eslint-disable-line no-eq-null,eqeqeq\n            throw new Error('task callback must be a function');\n        }\n\n        q.started = true;\n\n        if (data == null && q.idle()) { // eslint-disable-line no-eq-null,eqeqeq\n            // call drain immediately if there are no tasks\n            setTimeout(function () {\n                q.drain();\n            }, 1);\n\n            return;\n        }\n\n        var item = {\n            data: data,\n            callback: typeof callback === 'function' ? callback : _noop\n        };\n\n        if (insertAtFront) {\n            q._tasks.unshift(item);\n        }\n        else {\n            q._tasks.push(item);\n        }\n\n        setTimeout(function () {\n            q.process();\n        }, 1);\n    }\n\n    function _next(task) {\n        return function () {\n            workers -= 1;\n\n            task.callback.apply(task, arguments);\n\n            if (arguments[0] != null) { // eslint-disable-line no-eq-null,eqeqeq\n                q.error(arguments[0], task.data);\n            }\n\n            if (workers <= (q.concurrency - q.buffer)) {\n                q.unsaturated();\n            }\n\n            if (q.idle()) {\n                q.drain();\n            }\n\n            q.process();\n        };\n    }\n\n    return q;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}