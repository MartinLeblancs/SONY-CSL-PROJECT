{"ast":null,"code":"var core = require('../core'),\n    tempPoint = new core.Point(),\n    tempPolygon = new core.Polygon();\n/**\n * Base mesh class\n * @class\n * @extends PIXI.Container\n * @memberof PIXI.mesh\n * @param texture {Texture} The texture to use\n * @param [vertices] {Float32Arrif you want to specify the vertices\n * @param [uvs] {Float32Array} if you want to specify the uvs\n * @param [indices] {Uint16Array} if you want to specify the indices\n * @param [drawMode] {number} the drawMode, can be any of the Mesh.DRAW_MODES consts\n */\n\n\nfunction Mesh(texture, vertices, uvs, indices, drawMode) {\n  core.Container.call(this);\n  /**\n   * The texture of the Mesh\n   *\n   * @member {Texture}\n   * @private\n   */\n\n  this._texture = null;\n  /**\n   * The Uvs of the Mesh\n   *\n   * @member {Float32Array}\n   */\n\n  this.uvs = uvs || new Float32Array([0, 1, 1, 1, 1, 0, 0, 1]);\n  /**\n   * An array of vertices\n   *\n   * @member {Float32Array}\n   */\n\n  this.vertices = vertices || new Float32Array([0, 0, 100, 0, 100, 100, 0, 100]);\n  /*\n   * @member {Uint16Array} An array containing the indices of the vertices\n   */\n  //  TODO auto generate this based on draw mode!\n\n  this.indices = indices || new Uint16Array([0, 1, 2, 3]);\n  /**\n   * Whether the Mesh is dirty or not\n   *\n   * @member {boolean}\n   */\n\n  this.dirty = true;\n  /**\n   * The blend mode to be applied to the sprite. Set to blendModes.NORMAL to remove any blend mode.\n   *\n   * @member {number}\n   * @default CONST.BLEND_MODES.NORMAL;\n   */\n\n  this.blendMode = core.BLEND_MODES.NORMAL;\n  /**\n   * Triangles in canvas mode are automatically antialiased, use this value to force triangles to overlap a bit with each other.\n   *\n   * @member {number}\n   */\n\n  this.canvasPadding = 0;\n  /**\n   * The way the Mesh should be drawn, can be any of the Mesh.DRAW_MODES consts\n   *\n   * @member {number}\n   */\n\n  this.drawMode = drawMode || Mesh.DRAW_MODES.TRIANGLE_MESH; // run texture setter;\n\n  this.texture = texture;\n} // constructor\n\n\nMesh.prototype = Object.create(core.Container.prototype);\nMesh.prototype.constructor = Mesh;\nmodule.exports = Mesh;\nObject.defineProperties(Mesh.prototype, {\n  /**\n   * The texture that the sprite is using\n   *\n   * @member {PIXI.Texture}\n   * @memberof PIXI.mesh.Mesh#\n   */\n  texture: {\n    get: function get() {\n      return this._texture;\n    },\n    set: function set(value) {\n      if (this._texture === value) {\n        return;\n      }\n\n      this._texture = value;\n\n      if (value) {\n        // wait for the texture to load\n        if (value.baseTexture.hasLoaded) {\n          this._onTextureUpdate();\n        } else {\n          value.once('update', this._onTextureUpdate, this);\n        }\n      }\n    }\n  }\n});\n/**\n * Renders the object using the WebGL renderer\n *\n * @param renderer {WebGLRenderer} a reference to the WebGL renderer\n * @private\n */\n\nMesh.prototype._renderWebGL = function (renderer) {\n  renderer.setObjectRenderer(renderer.plugins.mesh);\n  renderer.plugins.mesh.render(this);\n};\n/**\n * Renders the object using the Canvas renderer\n *\n * @param renderer {CanvasRenderer}\n * @private\n */\n\n\nMesh.prototype._renderCanvas = function (renderer) {\n  var context = renderer.context;\n  var transform = this.worldTransform;\n\n  if (renderer.roundPixels) {\n    context.setTransform(transform.a, transform.b, transform.c, transform.d, transform.tx | 0, transform.ty | 0);\n  } else {\n    context.setTransform(transform.a, transform.b, transform.c, transform.d, transform.tx, transform.ty);\n  }\n\n  if (this.drawMode === Mesh.DRAW_MODES.TRIANGLE_MESH) {\n    this._renderCanvasTriangleMesh(context);\n  } else {\n    this._renderCanvasTriangles(context);\n  }\n};\n/**\n * Draws the object in Triangle Mesh mode using canvas\n *\n * @param context {CanvasRenderingContext2D} the current drawing context\n * @private\n */\n\n\nMesh.prototype._renderCanvasTriangleMesh = function (context) {\n  // draw triangles!!\n  var vertices = this.vertices;\n  var uvs = this.uvs;\n  var length = vertices.length / 2; // this.count++;\n\n  for (var i = 0; i < length - 2; i++) {\n    // draw some triangles!\n    var index = i * 2;\n\n    this._renderCanvasDrawTriangle(context, vertices, uvs, index, index + 2, index + 4);\n  }\n};\n/**\n * Draws the object in triangle mode using canvas\n *\n * @param context {CanvasRenderingContext2D} the current drawing context\n * @private\n */\n\n\nMesh.prototype._renderCanvasTriangles = function (context) {\n  // draw triangles!!\n  var vertices = this.vertices;\n  var uvs = this.uvs;\n  var indices = this.indices;\n  var length = indices.length; // this.count++;\n\n  for (var i = 0; i < length; i += 3) {\n    // draw some triangles!\n    var index0 = indices[i] * 2,\n        index1 = indices[i + 1] * 2,\n        index2 = indices[i + 2] * 2;\n\n    this._renderCanvasDrawTriangle(context, vertices, uvs, index0, index1, index2);\n  }\n};\n/**\n * Draws one of the triangles that form this Mesh\n *\n * @param context {CanvasRenderingContext2D} the current drawing context\n * @param vertices {Float32Array} a reference to the vertices of the Mesh\n * @param uvs {Float32Array} a reference to the uvs of the Mesh\n * @param index0 {number} the index of the first vertex\n * @param index1 {number} the index of the second vertex\n * @param index2 {number} the index of the third vertex\n * @private\n */\n\n\nMesh.prototype._renderCanvasDrawTriangle = function (context, vertices, uvs, index0, index1, index2) {\n  var textureSource = this._texture.baseTexture.source;\n  var textureWidth = this._texture.baseTexture.width;\n  var textureHeight = this._texture.baseTexture.height;\n  var x0 = vertices[index0],\n      x1 = vertices[index1],\n      x2 = vertices[index2];\n  var y0 = vertices[index0 + 1],\n      y1 = vertices[index1 + 1],\n      y2 = vertices[index2 + 1];\n  var u0 = uvs[index0] * textureWidth,\n      u1 = uvs[index1] * textureWidth,\n      u2 = uvs[index2] * textureWidth;\n  var v0 = uvs[index0 + 1] * textureHeight,\n      v1 = uvs[index1 + 1] * textureHeight,\n      v2 = uvs[index2 + 1] * textureHeight;\n\n  if (this.canvasPadding > 0) {\n    var paddingX = this.canvasPadding / this.worldTransform.a;\n    var paddingY = this.canvasPadding / this.worldTransform.d;\n    var centerX = (x0 + x1 + x2) / 3;\n    var centerY = (y0 + y1 + y2) / 3;\n    var normX = x0 - centerX;\n    var normY = y0 - centerY;\n    var dist = Math.sqrt(normX * normX + normY * normY);\n    x0 = centerX + normX / dist * (dist + paddingX);\n    y0 = centerY + normY / dist * (dist + paddingY); //\n\n    normX = x1 - centerX;\n    normY = y1 - centerY;\n    dist = Math.sqrt(normX * normX + normY * normY);\n    x1 = centerX + normX / dist * (dist + paddingX);\n    y1 = centerY + normY / dist * (dist + paddingY);\n    normX = x2 - centerX;\n    normY = y2 - centerY;\n    dist = Math.sqrt(normX * normX + normY * normY);\n    x2 = centerX + normX / dist * (dist + paddingX);\n    y2 = centerY + normY / dist * (dist + paddingY);\n  }\n\n  context.save();\n  context.beginPath();\n  context.moveTo(x0, y0);\n  context.lineTo(x1, y1);\n  context.lineTo(x2, y2);\n  context.closePath();\n  context.clip(); // Compute matrix transform\n\n  var delta = u0 * v1 + v0 * u2 + u1 * v2 - v1 * u2 - v0 * u1 - u0 * v2;\n  var deltaA = x0 * v1 + v0 * x2 + x1 * v2 - v1 * x2 - v0 * x1 - x0 * v2;\n  var deltaB = u0 * x1 + x0 * u2 + u1 * x2 - x1 * u2 - x0 * u1 - u0 * x2;\n  var deltaC = u0 * v1 * x2 + v0 * x1 * u2 + x0 * u1 * v2 - x0 * v1 * u2 - v0 * u1 * x2 - u0 * x1 * v2;\n  var deltaD = y0 * v1 + v0 * y2 + y1 * v2 - v1 * y2 - v0 * y1 - y0 * v2;\n  var deltaE = u0 * y1 + y0 * u2 + u1 * y2 - y1 * u2 - y0 * u1 - u0 * y2;\n  var deltaF = u0 * v1 * y2 + v0 * y1 * u2 + y0 * u1 * v2 - y0 * v1 * u2 - v0 * u1 * y2 - u0 * y1 * v2;\n  context.transform(deltaA / delta, deltaD / delta, deltaB / delta, deltaE / delta, deltaC / delta, deltaF / delta);\n  context.drawImage(textureSource, 0, 0);\n  context.restore();\n};\n/**\n * Renders a flat Mesh\n *\n * @param Mesh {Mesh} The Mesh to render\n * @private\n */\n\n\nMesh.prototype.renderMeshFlat = function (Mesh) {\n  var context = this.context;\n  var vertices = Mesh.vertices;\n  var length = vertices.length / 2; // this.count++;\n\n  context.beginPath();\n\n  for (var i = 1; i < length - 2; i++) {\n    // draw some triangles!\n    var index = i * 2;\n    var x0 = vertices[index],\n        x1 = vertices[index + 2],\n        x2 = vertices[index + 4];\n    var y0 = vertices[index + 1],\n        y1 = vertices[index + 3],\n        y2 = vertices[index + 5];\n    context.moveTo(x0, y0);\n    context.lineTo(x1, y1);\n    context.lineTo(x2, y2);\n  }\n\n  context.fillStyle = '#FF0000';\n  context.fill();\n  context.closePath();\n};\n/*\n Mesh.prototype.setTexture = function (texture)\n {\n //TODO SET THE TEXTURES\n //TODO VISIBILITY\n //TODO SETTER\n\n // stop current texture\n this.texture = texture;\n this.width   = texture.frame.width;\n this.height  = texture.frame.height;\n this.updateFrame = true;\n };\n */\n\n/**\n * When the texture is updated, this event will fire to update the scale and frame\n *\n * @param event\n * @private\n */\n\n\nMesh.prototype._onTextureUpdate = function () {\n  this.updateFrame = true;\n};\n/**\n * Returns the bounds of the mesh as a rectangle. The bounds calculation takes the worldTransform into account.\n *\n * @param matrix {Matrix} the transformation matrix of the sprite\n * @return {Rectangle} the framing rectangle\n */\n\n\nMesh.prototype.getBounds = function (matrix) {\n  if (!this._currentBounds) {\n    var worldTransform = matrix || this.worldTransform;\n    var a = worldTransform.a;\n    var b = worldTransform.b;\n    var c = worldTransform.c;\n    var d = worldTransform.d;\n    var tx = worldTransform.tx;\n    var ty = worldTransform.ty;\n    var maxX = -Infinity;\n    var maxY = -Infinity;\n    var minX = Infinity;\n    var minY = Infinity;\n    var vertices = this.vertices;\n\n    for (var i = 0, n = vertices.length; i < n; i += 2) {\n      var rawX = vertices[i],\n          rawY = vertices[i + 1];\n      var x = a * rawX + c * rawY + tx;\n      var y = d * rawY + b * rawX + ty;\n      minX = x < minX ? x : minX;\n      minY = y < minY ? y : minY;\n      maxX = x > maxX ? x : maxX;\n      maxY = y > maxY ? y : maxY;\n    }\n\n    if (minX === -Infinity || maxY === Infinity) {\n      return core.Rectangle.EMPTY;\n    }\n\n    var bounds = this._bounds;\n    bounds.x = minX;\n    bounds.width = maxX - minX;\n    bounds.y = minY;\n    bounds.height = maxY - minY; // store a reference so that if this function gets called again in the render cycle we do not have to recalculate\n\n    this._currentBounds = bounds;\n  }\n\n  return this._currentBounds;\n};\n/**\n * Tests if a point is inside this mesh. Works only for TRIANGLE_MESH\n *\n * @param point {Point} the point to test\n * @return {boolean} the result of the test\n */\n\n\nMesh.prototype.containsPoint = function (point) {\n  if (!this.getBounds().contains(point.x, point.y)) {\n    return false;\n  }\n\n  this.worldTransform.applyInverse(point, tempPoint);\n  var vertices = this.vertices;\n  var points = tempPolygon.points;\n  var i, len;\n\n  if (this.drawMode === Mesh.DRAW_MODES.TRIANGLES) {\n    var indices = this.indices;\n    len = this.indices.length; //TODO: inline this.\n\n    for (i = 0; i < len; i += 3) {\n      var ind0 = indices[i] * 2,\n          ind1 = indices[i + 1] * 2,\n          ind2 = indices[i + 2] * 2;\n      points[0] = vertices[ind0];\n      points[1] = vertices[ind0 + 1];\n      points[2] = vertices[ind1];\n      points[3] = vertices[ind1 + 1];\n      points[4] = vertices[ind2];\n      points[5] = vertices[ind2 + 1];\n\n      if (tempPolygon.contains(tempPoint.x, tempPoint.y)) {\n        return true;\n      }\n    }\n  } else {\n    len = vertices.length;\n\n    for (i = 0; i < len; i += 6) {\n      points[0] = vertices[i];\n      points[1] = vertices[i + 1];\n      points[2] = vertices[i + 2];\n      points[3] = vertices[i + 3];\n      points[4] = vertices[i + 4];\n      points[5] = vertices[i + 5];\n\n      if (tempPolygon.contains(tempPoint.x, tempPoint.y)) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n};\n/**\n * Different drawing buffer modes supported\n *\n * @static\n * @constant\n * @property {object} DRAW_MODES\n * @property {number} DRAW_MODES.TRIANGLE_MESH\n * @property {number} DRAW_MODES.TRIANGLES\n */\n\n\nMesh.DRAW_MODES = {\n  TRIANGLE_MESH: 0,\n  TRIANGLES: 1\n};","map":{"version":3,"names":["core","require","tempPoint","Point","tempPolygon","Polygon","Mesh","texture","vertices","uvs","indices","drawMode","Container","call","_texture","Float32Array","Uint16Array","dirty","blendMode","BLEND_MODES","NORMAL","canvasPadding","DRAW_MODES","TRIANGLE_MESH","prototype","Object","create","constructor","module","exports","defineProperties","get","set","value","baseTexture","hasLoaded","_onTextureUpdate","once","_renderWebGL","renderer","setObjectRenderer","plugins","mesh","render","_renderCanvas","context","transform","worldTransform","roundPixels","setTransform","a","b","c","d","tx","ty","_renderCanvasTriangleMesh","_renderCanvasTriangles","length","i","index","_renderCanvasDrawTriangle","index0","index1","index2","textureSource","source","textureWidth","width","textureHeight","height","x0","x1","x2","y0","y1","y2","u0","u1","u2","v0","v1","v2","paddingX","paddingY","centerX","centerY","normX","normY","dist","Math","sqrt","save","beginPath","moveTo","lineTo","closePath","clip","delta","deltaA","deltaB","deltaC","deltaD","deltaE","deltaF","drawImage","restore","renderMeshFlat","fillStyle","fill","updateFrame","getBounds","matrix","_currentBounds","maxX","Infinity","maxY","minX","minY","n","rawX","rawY","x","y","Rectangle","EMPTY","bounds","_bounds","containsPoint","point","contains","applyInverse","points","len","TRIANGLES","ind0","ind1","ind2"],"sources":["/home/reyden-martin/Documents/Tech2/HUB/Sony CSL/SONY-CSL-PROJECT/node_modules/react-piano-roll/node_modules/pixi.js/src/mesh/Mesh.js"],"sourcesContent":["var core = require('../core'),\n    tempPoint = new core.Point(),\n    tempPolygon = new core.Polygon();\n\n/**\n * Base mesh class\n * @class\n * @extends PIXI.Container\n * @memberof PIXI.mesh\n * @param texture {Texture} The texture to use\n * @param [vertices] {Float32Arrif you want to specify the vertices\n * @param [uvs] {Float32Array} if you want to specify the uvs\n * @param [indices] {Uint16Array} if you want to specify the indices\n * @param [drawMode] {number} the drawMode, can be any of the Mesh.DRAW_MODES consts\n */\nfunction Mesh(texture, vertices, uvs, indices, drawMode)\n{\n    core.Container.call(this);\n\n    /**\n     * The texture of the Mesh\n     *\n     * @member {Texture}\n     * @private\n     */\n    this._texture = null;\n\n    /**\n     * The Uvs of the Mesh\n     *\n     * @member {Float32Array}\n     */\n    this.uvs = uvs || new Float32Array([0, 1,\n        1, 1,\n        1, 0,\n        0, 1]);\n\n    /**\n     * An array of vertices\n     *\n     * @member {Float32Array}\n     */\n    this.vertices = vertices || new Float32Array([0, 0,\n        100, 0,\n        100, 100,\n        0, 100]);\n\n    /*\n     * @member {Uint16Array} An array containing the indices of the vertices\n     */\n    //  TODO auto generate this based on draw mode!\n    this.indices = indices || new Uint16Array([0, 1, 2, 3]);\n\n    /**\n     * Whether the Mesh is dirty or not\n     *\n     * @member {boolean}\n     */\n    this.dirty = true;\n\n    /**\n     * The blend mode to be applied to the sprite. Set to blendModes.NORMAL to remove any blend mode.\n     *\n     * @member {number}\n     * @default CONST.BLEND_MODES.NORMAL;\n     */\n    this.blendMode = core.BLEND_MODES.NORMAL;\n\n    /**\n     * Triangles in canvas mode are automatically antialiased, use this value to force triangles to overlap a bit with each other.\n     *\n     * @member {number}\n     */\n    this.canvasPadding = 0;\n\n    /**\n     * The way the Mesh should be drawn, can be any of the Mesh.DRAW_MODES consts\n     *\n     * @member {number}\n     */\n    this.drawMode = drawMode || Mesh.DRAW_MODES.TRIANGLE_MESH;\n\n    // run texture setter;\n    this.texture = texture;\n}\n\n// constructor\nMesh.prototype = Object.create(core.Container.prototype);\nMesh.prototype.constructor = Mesh;\nmodule.exports = Mesh;\n\nObject.defineProperties(Mesh.prototype, {\n    /**\n     * The texture that the sprite is using\n     *\n     * @member {PIXI.Texture}\n     * @memberof PIXI.mesh.Mesh#\n     */\n    texture: {\n        get: function ()\n        {\n            return  this._texture;\n        },\n        set: function (value)\n        {\n            if (this._texture === value)\n            {\n                return;\n            }\n\n            this._texture = value;\n\n            if (value)\n            {\n                // wait for the texture to load\n                if (value.baseTexture.hasLoaded)\n                {\n                    this._onTextureUpdate();\n                }\n                else\n                {\n                    value.once('update', this._onTextureUpdate, this);\n                }\n            }\n        }\n    }\n});\n\n/**\n * Renders the object using the WebGL renderer\n *\n * @param renderer {WebGLRenderer} a reference to the WebGL renderer\n * @private\n */\nMesh.prototype._renderWebGL = function (renderer)\n{\n    renderer.setObjectRenderer(renderer.plugins.mesh);\n    renderer.plugins.mesh.render(this);\n};\n\n/**\n * Renders the object using the Canvas renderer\n *\n * @param renderer {CanvasRenderer}\n * @private\n */\nMesh.prototype._renderCanvas = function (renderer)\n{\n    var context = renderer.context;\n\n    var transform = this.worldTransform;\n\n    if (renderer.roundPixels)\n    {\n        context.setTransform(transform.a, transform.b, transform.c, transform.d, transform.tx | 0, transform.ty | 0);\n    }\n    else\n    {\n        context.setTransform(transform.a, transform.b, transform.c, transform.d, transform.tx, transform.ty);\n    }\n\n    if (this.drawMode === Mesh.DRAW_MODES.TRIANGLE_MESH)\n    {\n        this._renderCanvasTriangleMesh(context);\n    }\n    else\n    {\n        this._renderCanvasTriangles(context);\n    }\n};\n\n/**\n * Draws the object in Triangle Mesh mode using canvas\n *\n * @param context {CanvasRenderingContext2D} the current drawing context\n * @private\n */\nMesh.prototype._renderCanvasTriangleMesh = function (context)\n{\n    // draw triangles!!\n    var vertices = this.vertices;\n    var uvs = this.uvs;\n\n    var length = vertices.length / 2;\n    // this.count++;\n\n    for (var i = 0; i < length - 2; i++)\n    {\n        // draw some triangles!\n        var index = i * 2;\n        this._renderCanvasDrawTriangle(context, vertices, uvs, index, (index + 2), (index + 4));\n    }\n};\n\n/**\n * Draws the object in triangle mode using canvas\n *\n * @param context {CanvasRenderingContext2D} the current drawing context\n * @private\n */\nMesh.prototype._renderCanvasTriangles = function (context)\n{\n    // draw triangles!!\n    var vertices = this.vertices;\n    var uvs = this.uvs;\n    var indices = this.indices;\n\n    var length = indices.length;\n    // this.count++;\n\n    for (var i = 0; i < length; i += 3)\n    {\n        // draw some triangles!\n        var index0 = indices[i] * 2, index1 = indices[i + 1] * 2, index2 = indices[i + 2] * 2;\n        this._renderCanvasDrawTriangle(context, vertices, uvs, index0, index1, index2);\n    }\n};\n\n/**\n * Draws one of the triangles that form this Mesh\n *\n * @param context {CanvasRenderingContext2D} the current drawing context\n * @param vertices {Float32Array} a reference to the vertices of the Mesh\n * @param uvs {Float32Array} a reference to the uvs of the Mesh\n * @param index0 {number} the index of the first vertex\n * @param index1 {number} the index of the second vertex\n * @param index2 {number} the index of the third vertex\n * @private\n */\nMesh.prototype._renderCanvasDrawTriangle = function (context, vertices, uvs, index0, index1, index2)\n{\n    var textureSource = this._texture.baseTexture.source;\n    var textureWidth = this._texture.baseTexture.width;\n    var textureHeight = this._texture.baseTexture.height;\n\n    var x0 = vertices[index0], x1 = vertices[index1], x2 = vertices[index2];\n    var y0 = vertices[index0 + 1], y1 = vertices[index1 + 1], y2 = vertices[index2 + 1];\n\n    var u0 = uvs[index0] * textureWidth, u1 = uvs[index1] * textureWidth, u2 = uvs[index2] * textureWidth;\n    var v0 = uvs[index0 + 1] * textureHeight, v1 = uvs[index1 + 1] * textureHeight, v2 = uvs[index2 + 1] * textureHeight;\n\n    if (this.canvasPadding > 0)\n    {\n        var paddingX = this.canvasPadding / this.worldTransform.a;\n        var paddingY = this.canvasPadding / this.worldTransform.d;\n        var centerX = (x0 + x1 + x2) / 3;\n        var centerY = (y0 + y1 + y2) / 3;\n\n        var normX = x0 - centerX;\n        var normY = y0 - centerY;\n\n        var dist = Math.sqrt(normX * normX + normY * normY);\n        x0 = centerX + (normX / dist) * (dist + paddingX);\n        y0 = centerY + (normY / dist) * (dist + paddingY);\n\n        //\n\n        normX = x1 - centerX;\n        normY = y1 - centerY;\n\n        dist = Math.sqrt(normX * normX + normY * normY);\n        x1 = centerX + (normX / dist) * (dist + paddingX);\n        y1 = centerY + (normY / dist) * (dist + paddingY);\n\n        normX = x2 - centerX;\n        normY = y2 - centerY;\n\n        dist = Math.sqrt(normX * normX + normY * normY);\n        x2 = centerX + (normX / dist) * (dist + paddingX);\n        y2 = centerY + (normY / dist) * (dist + paddingY);\n    }\n\n    context.save();\n    context.beginPath();\n\n\n    context.moveTo(x0, y0);\n    context.lineTo(x1, y1);\n    context.lineTo(x2, y2);\n\n    context.closePath();\n\n    context.clip();\n\n    // Compute matrix transform\n    var delta =  (u0 * v1)      + (v0 * u2)      + (u1 * v2)      - (v1 * u2)      - (v0 * u1)      - (u0 * v2);\n    var deltaA = (x0 * v1)      + (v0 * x2)      + (x1 * v2)      - (v1 * x2)      - (v0 * x1)      - (x0 * v2);\n    var deltaB = (u0 * x1)      + (x0 * u2)      + (u1 * x2)      - (x1 * u2)      - (x0 * u1)      - (u0 * x2);\n    var deltaC = (u0 * v1 * x2) + (v0 * x1 * u2) + (x0 * u1 * v2) - (x0 * v1 * u2) - (v0 * u1 * x2) - (u0 * x1 * v2);\n    var deltaD = (y0 * v1)      + (v0 * y2)      + (y1 * v2)      - (v1 * y2)      - (v0 * y1)      - (y0 * v2);\n    var deltaE = (u0 * y1)      + (y0 * u2)      + (u1 * y2)      - (y1 * u2)      - (y0 * u1)      - (u0 * y2);\n    var deltaF = (u0 * v1 * y2) + (v0 * y1 * u2) + (y0 * u1 * v2) - (y0 * v1 * u2) - (v0 * u1 * y2) - (u0 * y1 * v2);\n\n    context.transform(deltaA / delta, deltaD / delta,\n        deltaB / delta, deltaE / delta,\n        deltaC / delta, deltaF / delta);\n\n    context.drawImage(textureSource, 0, 0);\n    context.restore();\n};\n\n\n\n/**\n * Renders a flat Mesh\n *\n * @param Mesh {Mesh} The Mesh to render\n * @private\n */\nMesh.prototype.renderMeshFlat = function (Mesh)\n{\n    var context = this.context;\n    var vertices = Mesh.vertices;\n\n    var length = vertices.length/2;\n    // this.count++;\n\n    context.beginPath();\n    for (var i=1; i < length-2; i++)\n    {\n        // draw some triangles!\n        var index = i*2;\n\n        var x0 = vertices[index],   x1 = vertices[index+2], x2 = vertices[index+4];\n        var y0 = vertices[index+1], y1 = vertices[index+3], y2 = vertices[index+5];\n\n        context.moveTo(x0, y0);\n        context.lineTo(x1, y1);\n        context.lineTo(x2, y2);\n    }\n\n    context.fillStyle = '#FF0000';\n    context.fill();\n    context.closePath();\n};\n\n/*\n Mesh.prototype.setTexture = function (texture)\n {\n //TODO SET THE TEXTURES\n //TODO VISIBILITY\n //TODO SETTER\n\n // stop current texture\n this.texture = texture;\n this.width   = texture.frame.width;\n this.height  = texture.frame.height;\n this.updateFrame = true;\n };\n */\n\n/**\n * When the texture is updated, this event will fire to update the scale and frame\n *\n * @param event\n * @private\n */\nMesh.prototype._onTextureUpdate = function ()\n{\n    this.updateFrame = true;\n};\n\n/**\n * Returns the bounds of the mesh as a rectangle. The bounds calculation takes the worldTransform into account.\n *\n * @param matrix {Matrix} the transformation matrix of the sprite\n * @return {Rectangle} the framing rectangle\n */\nMesh.prototype.getBounds = function (matrix)\n{\n    if (!this._currentBounds) {\n        var worldTransform = matrix || this.worldTransform;\n\n        var a = worldTransform.a;\n        var b = worldTransform.b;\n        var c = worldTransform.c;\n        var d = worldTransform.d;\n        var tx = worldTransform.tx;\n        var ty = worldTransform.ty;\n\n        var maxX = -Infinity;\n        var maxY = -Infinity;\n\n        var minX = Infinity;\n        var minY = Infinity;\n\n        var vertices = this.vertices;\n        for (var i = 0, n = vertices.length; i < n; i += 2) {\n            var rawX = vertices[i], rawY = vertices[i + 1];\n            var x = (a * rawX) + (c * rawY) + tx;\n            var y = (d * rawY) + (b * rawX) + ty;\n\n            minX = x < minX ? x : minX;\n            minY = y < minY ? y : minY;\n\n            maxX = x > maxX ? x : maxX;\n            maxY = y > maxY ? y : maxY;\n        }\n\n        if (minX === -Infinity || maxY === Infinity) {\n            return core.Rectangle.EMPTY;\n        }\n\n        var bounds = this._bounds;\n\n        bounds.x = minX;\n        bounds.width = maxX - minX;\n\n        bounds.y = minY;\n        bounds.height = maxY - minY;\n\n        // store a reference so that if this function gets called again in the render cycle we do not have to recalculate\n        this._currentBounds = bounds;\n    }\n\n    return this._currentBounds;\n};\n\n/**\n * Tests if a point is inside this mesh. Works only for TRIANGLE_MESH\n *\n * @param point {Point} the point to test\n * @return {boolean} the result of the test\n */\nMesh.prototype.containsPoint = function( point ) {\n    if (!this.getBounds().contains(point.x, point.y)) {\n        return false;\n    }\n    this.worldTransform.applyInverse(point,  tempPoint);\n\n    var vertices = this.vertices;\n    var points = tempPolygon.points;\n    var i, len;\n\n    if (this.drawMode === Mesh.DRAW_MODES.TRIANGLES) {\n        var indices = this.indices;\n        len = this.indices.length;\n        //TODO: inline this.\n        for (i=0;i<len;i+=3) {\n            var ind0 = indices[i]*2, ind1 = indices[i+1]*2, ind2 = indices[i+2]*2;\n            points[0] = vertices[ind0];\n            points[1] = vertices[ind0+1];\n            points[2] = vertices[ind1];\n            points[3] = vertices[ind1+1];\n            points[4] = vertices[ind2];\n            points[5] = vertices[ind2+1];\n            if (tempPolygon.contains(tempPoint.x, tempPoint.y)) {\n                return true;\n            }\n        }\n    } else {\n        len = vertices.length;\n        for (i=0;i<len;i+=6) {\n            points[0] = vertices[i];\n            points[1] = vertices[i+1];\n            points[2] = vertices[i+2];\n            points[3] = vertices[i+3];\n            points[4] = vertices[i+4];\n            points[5] = vertices[i+5];\n            if (tempPolygon.contains(tempPoint.x, tempPoint.y)) {\n                return true;\n            }\n        }\n    }\n    return false;\n};\n/**\n * Different drawing buffer modes supported\n *\n * @static\n * @constant\n * @property {object} DRAW_MODES\n * @property {number} DRAW_MODES.TRIANGLE_MESH\n * @property {number} DRAW_MODES.TRIANGLES\n */\nMesh.DRAW_MODES = {\n    TRIANGLE_MESH: 0,\n    TRIANGLES: 1\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}