{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\nimport musicalScaleColors from 'musical-scale-colors';\nimport * as pixi from 'pixi.js';\nimport * as teoria from 'teoria';\npixi.utils._saidHello = true;\n/**\n * JavaScript 2D WebGL / Canvas animated piano roll\n * @module pixiPianoRoll\n * @author Matthew Hasbach\n * @copyright Matthew Hasbach 2015\n * @license MIT\n */\n\n/**\n * Playback position expressed in bars:quarters:sixteenths format (e.g. `\"1:2:0\"`)\n * @typedef {string} transportTime\n * @global\n */\n\n/**\n * Musical note expressed in [Scientific notation]{@link https://en.wikipedia.org/wiki/Scientific_pitch_notation}, [Helmholtz notation]{@link https://en.wikipedia.org/wiki/Helmholtz_pitch_notation}, [piano key number]{@link https://en.wikipedia.org/wiki/Piano_key_frequencies}, [audio frequency]{@link https://en.wikipedia.org/wiki/Audio_frequency} (the closest note will be used), or [MIDI]{@link https://en.wikipedia.org/wiki/MIDI} note number\n * @typedef {string|number} note\n * @global\n */\n\n/**\n * Note duration expressed as a number (e.g. `1` for a whole note) or string (e.g. `\"4n\"` for a quarter note)\n * @typedef {string|number} noteDuration\n * @global\n */\n\n/**\n * See the typedefs for [transportTime]{@link transportTime}, [note]{@link note}, and [noteDuration]{@link noteDuration}\n * @typedef {Array.<Array<transportTime, note, noteDuration>>} noteData\n * @global\n */\n\n/**\n * Instantiate a pixiPianoRoll\n * @alias module:pixiPianoRoll\n * @param {Object} opt - Options object\n * @param {number} [opt.width=900] - Width of the piano roll\n * @param {number} [opt.height=400] - Height of the piano roll\n * @param {number} [opt.pianoKeyWidth=125] - Width of the piano keys\n * @param {number|Object<number>} [opt.noteColor=musicalScaleColors.dDJameson] - Hexadecimal color of every note or object that has pitch class (chroma) property names and hexadecimal color values. See [musical-scale-colors]{@link https://github.com/mjhasbach/musical-scale-colors} for palettes (including the default).\n * @param {number} [opt.noteColor=0x333333] - Hexadecimal color of the grid lines\n * @param {number} [opt.noteColor=0] - Hexadecimal color of the background\n * @param {number} [opt.bpm=140] - Beats per minute\n * @param {boolean} [opt.activateKeys=true] - If true, the color of the piano keys will change to the color of the notes that intersect them\n * @param {boolean} [opt.antialias=true] - Whether or not the renderer will use antialiasing\n * @param {number} [opt.zoom=4] - Amount of visible measures\n * @param {number} [opt.resolution=1] - Amount of vertical grid lines per measure\n * @param {transportTime} [opt.time=0:0:0] - The [transportTime]{@link transportTime} at which playback will begin\n * @param {string} [opt.renderer=WebGLRenderer] - Determines the renderer type. Must be `\"WebGLRenderer\"` or `\"CanvasRenderer\"`.\n * @param {string} [opt.noteFormat=String] - The format of the [notes]{@link note} in `opt.noteData`. `\"String\"` for scientific or Helmholtz notation, `\"Key\"` for piano key numbers, `\"Frequency\"` for audio frequencies, or `\"MIDI\"` for MIDI note numbers.\n * @param {noteData} [opt.noteData=[]] - Note data\n * @returns {pianoRollAPI}\n * @example\nvar pianoRoll = pixiPianoRoll({\n    width: 900,\n    height: 400,\n    noteColor: 0xdb000f,\n    gridLineColor: 0x333333,\n    blackGridBgColor: 0x1e1e1e,\n    whiteGridBgColor: 0x282828,\n    bpm: 140,\n    antialias: true,\n    zoom: 4,\n    resolution: 2,\n    time: '0:0:0',\n    renderer: 'WebGLRenderer',\n    noteFormat: 'String',\n    noteData: [\n        ['0:0:0', 'C4', '2n'],\n        ['0:0:0', 'D4', '2n'],\n        ['0:0:0', 'E4', '2n'],\n        ['0:2:0', 'B4', '4n'],\n        ['0:3:0', 'A#4', '4n']\n    ]\n});\n\ndocument.getElementsByTagName('body')[0].appendChild(pianoRoll.view);\n\npianoRoll.playback.play();\n */\n\nfunction pixiPianoRoll(opt) {\n  var colors = {\n    blackKey: 0x000000,\n    whiteKey: 0xffffff,\n    blackGridBg: 0x1e1e1e,\n    whiteGridBg: 0x282828\n  };\n  opt = Object.assign({\n    width: 900,\n    height: 400,\n    pianoKeyWidth: 125,\n    noteColor: musicalScaleColors.dDJameson,\n    gridLineColor: 0x333333,\n    blackGridBgColor: colors.blackGridBg,\n    whiteGridBgColor: colors.whiteGridBg,\n    bpm: 140,\n    activateKeys: true,\n    antialias: true,\n    zoom: 4,\n    resolution: 1,\n    time: '0:0:0',\n    renderer: 'WebGLRenderer',\n    noteFormat: 'String',\n    noteData: []\n  }, opt);\n  var keys,\n      lastTime,\n      beatsPerMs,\n      pxMovementPerMs,\n      noteContainer,\n      noteRange,\n      noteRangeDiff,\n      noteHeight,\n      innerNoteHeight,\n      pianoContainer,\n      barWidth,\n      beatWidth,\n      sixteenthWidth,\n      gridLineWidth,\n      halfGridLineWidth,\n      gridLineSpacing,\n      activeKeys,\n      playing = false,\n      stage = new pixi.Container(),\n      rollContainer = new pixi.Container(),\n      gridlineContainers = {\n    main: new pixi.Container()\n  },\n      renderer = new pixi[opt.renderer](opt.width, opt.height, {\n    antialias: opt.antialias,\n    autoResize: true\n  });\n\n  function getTeoriaNote(note) {\n    var noteObj = teoria.note['from' + opt.noteFormat](note);\n    return opt.noteFormat === 'Frequency' ? noteObj.note : noteObj;\n  }\n\n  function getNoteRange() {\n    var min, max;\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = opt.noteData[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var _ref3 = _step.value;\n\n        var _ref2 = _slicedToArray(_ref3, 2);\n\n        var note = _ref2[1];\n        var keyNumber = getTeoriaNote(note).key();\n\n        if (keyNumber < min || typeof min !== 'number') {\n          min = keyNumber;\n        }\n\n        if (keyNumber > max || typeof max !== 'number') {\n          max = keyNumber;\n        }\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return != null) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    return {\n      min: min - 1,\n      max: max\n    };\n  }\n\n  function drawPianoKey(key, active) {\n    return (key.graphic || new pixi.Graphics()).clear().beginFill(active ? key.activeColor : key.color).lineStyle(key.color === colors.whiteKey ? noteHeight / 10 : 0, colors.blackKey).drawRect(0, key.y, key.width, key.height).endFill();\n  }\n\n  function drawPianoKeys() {\n    var whiteKeys = [],\n        blackKeys = [],\n        blackKeyWidth = opt.pianoKeyWidth / 1.575;\n    keys = {};\n    activeKeys = new Set();\n    stage.removeChild(pianoContainer);\n    pianoContainer = new pixi.Container();\n\n    for (var i = noteRange.min; i < noteRange.max + 2; i++) {\n      var y = opt.height + (noteRange.min - i) * noteHeight,\n          note = teoria.note.fromKey(i),\n          chroma = note.chroma(),\n          key = {\n        keyNumber: note.key(),\n        activeColor: typeof opt.noteColor === 'number' ? opt.noteColor : opt.noteColor[chroma]\n      };\n\n      if (new Set([0, 2, 4, 5, 7, 9, 11]).has(chroma)) {\n        whiteKeys.push(Object.assign(key, {\n          y: y + (new Set([4, 11]).has(chroma) ? 0 : -noteHeight / 2),\n          width: opt.pianoKeyWidth,\n          height: new Set([2, 7, 9]).has(chroma) ? noteHeight * 2 : noteHeight * 1.5,\n          color: colors.whiteKey\n        }));\n      } else {\n        blackKeys.push(Object.assign(key, {\n          y: y,\n          width: blackKeyWidth,\n          height: noteHeight,\n          color: colors.blackKey\n        }));\n      }\n    }\n\n    whiteKeys.concat(blackKeys).forEach(function (key) {\n      var pixiKey = drawPianoKey(key);\n      keys[key.keyNumber] = Object.assign(key, {\n        graphic: pixiKey\n      });\n      pianoContainer.addChild(pixiKey);\n    });\n    stage.addChild(pianoContainer);\n  }\n\n  function transportTimeToX(transportTime, isNote) {\n    if (!transportTime) {\n      return 0;\n    }\n\n    var _transportTime$split = transportTime.split(':'),\n        _transportTime$split2 = _slicedToArray(_transportTime$split, 3),\n        bar = _transportTime$split2[0],\n        _transportTime$split3 = _transportTime$split2[1],\n        quarter = _transportTime$split3 === void 0 ? 0 : _transportTime$split3,\n        _transportTime$split4 = _transportTime$split2[2],\n        sixteenth = _transportTime$split4 === void 0 ? 0 : _transportTime$split4,\n        x = barWidth * bar + beatWidth * quarter + sixteenthWidth * sixteenth;\n\n    return isNote ? x : opt.pianoKeyWidth - x;\n  }\n\n  function drawNotes() {\n    var oldContainer = rollContainer.removeChild(noteContainer);\n    noteContainer = new pixi.Container();\n    var _iteratorNormalCompletion2 = true;\n    var _didIteratorError2 = false;\n    var _iteratorError2 = undefined;\n\n    try {\n      for (var _iterator2 = opt.noteData[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n        var _ref6 = _step2.value;\n\n        var _ref5 = _slicedToArray(_ref6, 3);\n\n        var transportTime = _ref5[0];\n        var note = _ref5[1];\n        var duration = _ref5[2];\n        var pixiNote = new pixi.Graphics(),\n            teoriaNote = getTeoriaNote(note),\n            keyNumber = teoriaNote.key(),\n            color = typeof opt.noteColor === 'number' ? opt.noteColor : opt.noteColor[teoriaNote.chroma()];\n        pixiNote.beginFill(color).drawRect(0, 0, barWidth / parseInt(duration), innerNoteHeight).endFill();\n        pixiNote.x = transportTimeToX(transportTime, true) + halfGridLineWidth;\n        pixiNote.y = opt.height - (keyNumber - noteRange.min) * noteHeight + halfGridLineWidth;\n        pixiNote.keyNumber = keyNumber;\n        noteContainer.addChild(pixiNote);\n      }\n    } catch (err) {\n      _didIteratorError2 = true;\n      _iteratorError2 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n          _iterator2.return();\n        }\n      } finally {\n        if (_didIteratorError2) {\n          throw _iteratorError2;\n        }\n      }\n    }\n\n    noteContainer.x = oldContainer ? oldContainer.x : transportTimeToX(opt.time);\n    rollContainer.addChild(noteContainer);\n  }\n\n  function moveVerticalGridLines(horizontalMovement) {\n    var verticalGridlines = gridlineContainers.vertical.children;\n    var _iteratorNormalCompletion3 = true;\n    var _didIteratorError3 = false;\n    var _iteratorError3 = undefined;\n\n    try {\n      for (var _iterator3 = verticalGridlines[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n        var _line = _step3.value;\n        _line.x -= horizontalMovement;\n      }\n    } catch (err) {\n      _didIteratorError3 = true;\n      _iteratorError3 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion3 && _iterator3.return != null) {\n          _iterator3.return();\n        }\n      } finally {\n        if (_didIteratorError3) {\n          throw _iteratorError3;\n        }\n      }\n    }\n\n    if (verticalGridlines[0].x + gridLineWidth < opt.pianoKeyWidth) {\n      var line = gridlineContainers.vertical.removeChildAt(0);\n      line.x = verticalGridlines[verticalGridlines.length - 1].x + gridLineSpacing;\n      gridlineContainers.vertical.addChild(line);\n    }\n  }\n\n  function getFirstVerticalGridLineX(transportX) {\n    var x = transportX;\n\n    while (x + gridLineSpacing < opt.pianoKeyWidth) {\n      x += gridLineSpacing;\n    }\n\n    return x;\n  }\n\n  function drawGridlines(type) {\n    var i;\n\n    if (!type || type === 'horizontal') {\n      gridlineContainers.main.removeChild(gridlineContainers.horizontal);\n      gridlineContainers.horizontal = new pixi.Container();\n\n      for (i = 0; i < noteRangeDiff + 1; i++) {\n        gridlineContainers.horizontal.addChild(new pixi.Graphics().beginFill(opt.gridLineColor).drawRect(0, i * noteHeight - halfGridLineWidth, opt.width, gridLineWidth).endFill());\n        var noteChroma = teoria.note.fromKey(i + 3).chroma();\n\n        if (new Set([0, 2, 4, 5, 7, 9, 11]).has(noteChroma)) {\n          gridlineContainers.horizontal.addChild(new pixi.Graphics().beginFill(opt.whiteGridBgColor).drawRect(0, i * noteHeight + halfGridLineWidth, opt.width, noteHeight - gridLineWidth).endFill());\n        }\n      }\n\n      gridlineContainers.main.addChild(gridlineContainers.horizontal);\n    }\n\n    if (!type || type === 'vertical') {\n      var offset = getFirstVerticalGridLineX(noteContainer ? noteContainer.x : transportTimeToX(opt.time));\n      gridlineContainers.main.removeChild(gridlineContainers.vertical);\n      gridlineContainers.vertical = new pixi.Container();\n\n      for (i = 0; i < opt.zoom * opt.resolution + 1; i++) {\n        var line = new pixi.Graphics().beginFill(opt.gridLineColor).drawRect(0, 0, gridLineWidth, opt.height).endFill();\n        line.x = offset + i * gridLineSpacing - halfGridLineWidth;\n        gridlineContainers.vertical.addChild(line);\n      }\n\n      gridlineContainers.main.addChild(gridlineContainers.vertical);\n    }\n\n    rollContainer.addChild(gridlineContainers.main);\n  }\n\n  function activateKeys() {\n    if (!opt.activateKeys) {\n      return;\n    }\n\n    var intersectedKeys = new Set();\n    var _iteratorNormalCompletion4 = true;\n    var _didIteratorError4 = false;\n    var _iteratorError4 = undefined;\n\n    try {\n      for (var _iterator4 = noteContainer.children[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n        var note = _step4.value;\n\n        if (note.containsPoint(new pixi.Point(opt.pianoKeyWidth, note.y))) {\n          intersectedKeys.add(note.keyNumber);\n        }\n      }\n    } catch (err) {\n      _didIteratorError4 = true;\n      _iteratorError4 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion4 && _iterator4.return != null) {\n          _iterator4.return();\n        }\n      } finally {\n        if (_didIteratorError4) {\n          throw _iteratorError4;\n        }\n      }\n    }\n\n    var _iteratorNormalCompletion5 = true;\n    var _didIteratorError5 = false;\n    var _iteratorError5 = undefined;\n\n    try {\n      for (var _iterator5 = intersectedKeys[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n        var intersectedKey = _step5.value;\n\n        if (!activeKeys.has(intersectedKey)) {\n          var key = keys[intersectedKey];\n          drawPianoKey(key, true);\n          activeKeys.add(intersectedKey);\n        }\n      }\n    } catch (err) {\n      _didIteratorError5 = true;\n      _iteratorError5 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion5 && _iterator5.return != null) {\n          _iterator5.return();\n        }\n      } finally {\n        if (_didIteratorError5) {\n          throw _iteratorError5;\n        }\n      }\n    }\n\n    var _iteratorNormalCompletion6 = true;\n    var _didIteratorError6 = false;\n    var _iteratorError6 = undefined;\n\n    try {\n      for (var _iterator6 = activeKeys[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {\n        var activeKey = _step6.value;\n\n        if (!intersectedKeys.has(activeKey)) {\n          var _key = keys[activeKey];\n          drawPianoKey(_key);\n          activeKeys.delete(activeKey);\n        }\n      }\n    } catch (err) {\n      _didIteratorError6 = true;\n      _iteratorError6 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion6 && _iterator6.return != null) {\n          _iterator6.return();\n        }\n      } finally {\n        if (_didIteratorError6) {\n          throw _iteratorError6;\n        }\n      }\n    }\n  }\n\n  function animate(frameTime) {\n    if (!lastTime) {\n      lastTime = frameTime;\n    }\n\n    var timeDiff = frameTime - lastTime,\n        horizontalMovement = timeDiff * pxMovementPerMs;\n    noteContainer.x = noteContainer.x - horizontalMovement;\n    moveVerticalGridLines(horizontalMovement);\n    activateKeys();\n    lastTime = frameTime;\n    renderer.render(stage);\n    playing ? requestAnimationFrame(animate) : lastTime = null;\n  }\n\n  function calculate() {\n    noteRange = getNoteRange(opt.noteData);\n    noteRangeDiff = noteRange.max - noteRange.min;\n    barWidth = (opt.width - opt.pianoKeyWidth) / opt.zoom;\n    beatWidth = (opt.width - opt.pianoKeyWidth) / (opt.zoom * 4);\n    sixteenthWidth = beatWidth / 4;\n    gridLineWidth = barWidth / 100;\n    halfGridLineWidth = gridLineWidth / 2;\n    gridLineSpacing = barWidth / opt.resolution;\n    beatsPerMs = opt.bpm / 60 / 1000;\n    pxMovementPerMs = beatWidth * beatsPerMs;\n    noteHeight = opt.height / noteRangeDiff;\n    innerNoteHeight = noteHeight - gridLineWidth;\n  }\n\n  (function init() {\n    stage.addChild(rollContainer);\n    calculate();\n    drawGridlines();\n    drawNotes();\n    drawPianoKeys();\n    renderer.backgroundColor = opt.blackGridBgColor;\n    renderer.render(stage);\n  })();\n  /**\n   * The piano roll API\n   * @typedef pianoRollAPI\n   * @type {Object}\n   * @global\n   */\n\n\n  var pianoRollAPI = {\n    /**\n     * Contains methods that control playback\n     * @memberof pianoRollAPI\n     * @type {Object}\n     */\n    playback: {\n      /**\n       * Pause if playing or play if paused\n       * @param {transportTime} [time] - If paused, the position to begin playing. If omitted, playback will begin at the current position.\n       */\n      toggle: function toggle(time) {\n        playing ? pianoRollAPI.playback.pause() : pianoRollAPI.playback.play(time);\n      },\n\n      /**\n       * Begin playback\n       * @param {transportTime} [time] - The position to begin playing. If omitted, playback will begin at the current position.\n       */\n      play: function play(time) {\n        if (!playing) {\n          if (time) {\n            pianoRollAPI.playback.seek(time);\n          }\n\n          playing = true;\n          requestAnimationFrame(animate);\n        }\n      },\n\n      /**\n       * Pause playback\n       */\n      pause: function pause() {\n        playing = false;\n      },\n\n      /**\n       * Change the playback position\n       * @param {transportTime} time - The new playback position\n       */\n      seek: function seek(time) {\n        opt.time = time;\n        noteContainer.x = transportTimeToX(time);\n        drawGridlines('vertical');\n        rollContainer.addChild(rollContainer.removeChild(noteContainer));\n        renderer.render(stage);\n      }\n    },\n\n    /**\n     * Change the bpm by changing this property\n     * @memberof pianoRollAPI\n     * @type {number}\n     */\n    set bpm(bpm) {\n      opt.bpm = bpm;\n      calculate();\n    },\n\n    /**\n     * Change the zoom by changing this property\n     * @memberof pianoRollAPI\n     * @type {number}\n     */\n    set zoom(zoom) {\n      opt.zoom = zoom;\n      calculate();\n      drawGridlines();\n      drawNotes();\n      renderer.render(stage);\n    },\n\n    /**\n     * Change the resolution by changing this property\n     * @memberof pianoRollAPI\n     * @type {number}\n     */\n    set resolution(resolution) {\n      opt.resolution = resolution;\n      calculate();\n      drawGridlines('vertical');\n      rollContainer.addChild(rollContainer.removeChild(noteContainer));\n      renderer.render(stage);\n    },\n\n    /**\n     * Change the note data by changing this property\n     * @memberof pianoRollAPI\n     * @type {noteData}\n     */\n    set noteData(noteData) {\n      opt.noteData = noteData;\n      calculate();\n      drawGridlines('horizontal');\n      drawNotes();\n      drawPianoKeys();\n      renderer.render(stage);\n    },\n\n    /**\n     * Whether or not playback is ongoing\n     * @memberof pianoRollAPI\n     * @type {boolean}\n     * @readonly\n     */\n    get playing() {\n      return playing;\n    },\n\n    /**\n     * The piano roll canvas element\n     * @memberof pianoRollAPI\n     * @type {HTMLElement}\n     * @readonly\n     */\n    get view() {\n      return renderer.view;\n    }\n\n  };\n  return pianoRollAPI;\n}\n\nexport default pixiPianoRoll;","map":{"version":3,"names":["_slicedToArray","musicalScaleColors","pixi","teoria","utils","_saidHello","pixiPianoRoll","opt","colors","blackKey","whiteKey","blackGridBg","whiteGridBg","Object","assign","width","height","pianoKeyWidth","noteColor","dDJameson","gridLineColor","blackGridBgColor","whiteGridBgColor","bpm","activateKeys","antialias","zoom","resolution","time","renderer","noteFormat","noteData","keys","lastTime","beatsPerMs","pxMovementPerMs","noteContainer","noteRange","noteRangeDiff","noteHeight","innerNoteHeight","pianoContainer","barWidth","beatWidth","sixteenthWidth","gridLineWidth","halfGridLineWidth","gridLineSpacing","activeKeys","playing","stage","Container","rollContainer","gridlineContainers","main","autoResize","getTeoriaNote","note","noteObj","getNoteRange","min","max","_iteratorNormalCompletion","_didIteratorError","_iteratorError","undefined","_iterator","Symbol","iterator","_step","next","done","_ref3","value","_ref2","keyNumber","key","err","return","drawPianoKey","active","graphic","Graphics","clear","beginFill","activeColor","color","lineStyle","drawRect","y","endFill","drawPianoKeys","whiteKeys","blackKeys","blackKeyWidth","Set","removeChild","i","fromKey","chroma","has","push","concat","forEach","pixiKey","addChild","transportTimeToX","transportTime","isNote","_transportTime$split","split","_transportTime$split2","bar","_transportTime$split3","quarter","_transportTime$split4","sixteenth","x","drawNotes","oldContainer","_iteratorNormalCompletion2","_didIteratorError2","_iteratorError2","_iterator2","_step2","_ref6","_ref5","duration","pixiNote","teoriaNote","parseInt","moveVerticalGridLines","horizontalMovement","verticalGridlines","vertical","children","_iteratorNormalCompletion3","_didIteratorError3","_iteratorError3","_iterator3","_step3","_line","line","removeChildAt","length","getFirstVerticalGridLineX","transportX","drawGridlines","type","horizontal","noteChroma","offset","intersectedKeys","_iteratorNormalCompletion4","_didIteratorError4","_iteratorError4","_iterator4","_step4","containsPoint","Point","add","_iteratorNormalCompletion5","_didIteratorError5","_iteratorError5","_iterator5","_step5","intersectedKey","_iteratorNormalCompletion6","_didIteratorError6","_iteratorError6","_iterator6","_step6","activeKey","_key","delete","animate","frameTime","timeDiff","render","requestAnimationFrame","calculate","init","backgroundColor","pianoRollAPI","playback","toggle","pause","play","seek","view"],"sources":["/home/reyden-martin/Documents/Tech2/HUB/Sony CSL/SONY-CSL-PROJECT/node_modules/react-piano-roll/dist/pixiPianoRoll.js"],"sourcesContent":["import _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\nimport musicalScaleColors from 'musical-scale-colors';\nimport * as pixi from 'pixi.js';\nimport * as teoria from 'teoria';\npixi.utils._saidHello = true;\n/**\n * JavaScript 2D WebGL / Canvas animated piano roll\n * @module pixiPianoRoll\n * @author Matthew Hasbach\n * @copyright Matthew Hasbach 2015\n * @license MIT\n */\n\n/**\n * Playback position expressed in bars:quarters:sixteenths format (e.g. `\"1:2:0\"`)\n * @typedef {string} transportTime\n * @global\n */\n\n/**\n * Musical note expressed in [Scientific notation]{@link https://en.wikipedia.org/wiki/Scientific_pitch_notation}, [Helmholtz notation]{@link https://en.wikipedia.org/wiki/Helmholtz_pitch_notation}, [piano key number]{@link https://en.wikipedia.org/wiki/Piano_key_frequencies}, [audio frequency]{@link https://en.wikipedia.org/wiki/Audio_frequency} (the closest note will be used), or [MIDI]{@link https://en.wikipedia.org/wiki/MIDI} note number\n * @typedef {string|number} note\n * @global\n */\n\n/**\n * Note duration expressed as a number (e.g. `1` for a whole note) or string (e.g. `\"4n\"` for a quarter note)\n * @typedef {string|number} noteDuration\n * @global\n */\n\n/**\n * See the typedefs for [transportTime]{@link transportTime}, [note]{@link note}, and [noteDuration]{@link noteDuration}\n * @typedef {Array.<Array<transportTime, note, noteDuration>>} noteData\n * @global\n */\n\n/**\n * Instantiate a pixiPianoRoll\n * @alias module:pixiPianoRoll\n * @param {Object} opt - Options object\n * @param {number} [opt.width=900] - Width of the piano roll\n * @param {number} [opt.height=400] - Height of the piano roll\n * @param {number} [opt.pianoKeyWidth=125] - Width of the piano keys\n * @param {number|Object<number>} [opt.noteColor=musicalScaleColors.dDJameson] - Hexadecimal color of every note or object that has pitch class (chroma) property names and hexadecimal color values. See [musical-scale-colors]{@link https://github.com/mjhasbach/musical-scale-colors} for palettes (including the default).\n * @param {number} [opt.noteColor=0x333333] - Hexadecimal color of the grid lines\n * @param {number} [opt.noteColor=0] - Hexadecimal color of the background\n * @param {number} [opt.bpm=140] - Beats per minute\n * @param {boolean} [opt.activateKeys=true] - If true, the color of the piano keys will change to the color of the notes that intersect them\n * @param {boolean} [opt.antialias=true] - Whether or not the renderer will use antialiasing\n * @param {number} [opt.zoom=4] - Amount of visible measures\n * @param {number} [opt.resolution=1] - Amount of vertical grid lines per measure\n * @param {transportTime} [opt.time=0:0:0] - The [transportTime]{@link transportTime} at which playback will begin\n * @param {string} [opt.renderer=WebGLRenderer] - Determines the renderer type. Must be `\"WebGLRenderer\"` or `\"CanvasRenderer\"`.\n * @param {string} [opt.noteFormat=String] - The format of the [notes]{@link note} in `opt.noteData`. `\"String\"` for scientific or Helmholtz notation, `\"Key\"` for piano key numbers, `\"Frequency\"` for audio frequencies, or `\"MIDI\"` for MIDI note numbers.\n * @param {noteData} [opt.noteData=[]] - Note data\n * @returns {pianoRollAPI}\n * @example\nvar pianoRoll = pixiPianoRoll({\n    width: 900,\n    height: 400,\n    noteColor: 0xdb000f,\n    gridLineColor: 0x333333,\n    blackGridBgColor: 0x1e1e1e,\n    whiteGridBgColor: 0x282828,\n    bpm: 140,\n    antialias: true,\n    zoom: 4,\n    resolution: 2,\n    time: '0:0:0',\n    renderer: 'WebGLRenderer',\n    noteFormat: 'String',\n    noteData: [\n        ['0:0:0', 'C4', '2n'],\n        ['0:0:0', 'D4', '2n'],\n        ['0:0:0', 'E4', '2n'],\n        ['0:2:0', 'B4', '4n'],\n        ['0:3:0', 'A#4', '4n']\n    ]\n});\n\ndocument.getElementsByTagName('body')[0].appendChild(pianoRoll.view);\n\npianoRoll.playback.play();\n */\n\nfunction pixiPianoRoll(opt) {\n  var colors = {\n    blackKey: 0x000000,\n    whiteKey: 0xffffff,\n    blackGridBg: 0x1e1e1e,\n    whiteGridBg: 0x282828\n  };\n  opt = Object.assign({\n    width: 900,\n    height: 400,\n    pianoKeyWidth: 125,\n    noteColor: musicalScaleColors.dDJameson,\n    gridLineColor: 0x333333,\n    blackGridBgColor: colors.blackGridBg,\n    whiteGridBgColor: colors.whiteGridBg,\n    bpm: 140,\n    activateKeys: true,\n    antialias: true,\n    zoom: 4,\n    resolution: 1,\n    time: '0:0:0',\n    renderer: 'WebGLRenderer',\n    noteFormat: 'String',\n    noteData: []\n  }, opt);\n  var keys,\n      lastTime,\n      beatsPerMs,\n      pxMovementPerMs,\n      noteContainer,\n      noteRange,\n      noteRangeDiff,\n      noteHeight,\n      innerNoteHeight,\n      pianoContainer,\n      barWidth,\n      beatWidth,\n      sixteenthWidth,\n      gridLineWidth,\n      halfGridLineWidth,\n      gridLineSpacing,\n      activeKeys,\n      playing = false,\n      stage = new pixi.Container(),\n      rollContainer = new pixi.Container(),\n      gridlineContainers = {\n    main: new pixi.Container()\n  },\n      renderer = new pixi[opt.renderer](opt.width, opt.height, {\n    antialias: opt.antialias,\n    autoResize: true\n  });\n\n  function getTeoriaNote(note) {\n    var noteObj = teoria.note['from' + opt.noteFormat](note);\n    return opt.noteFormat === 'Frequency' ? noteObj.note : noteObj;\n  }\n\n  function getNoteRange() {\n    var min, max;\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = opt.noteData[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var _ref3 = _step.value;\n\n        var _ref2 = _slicedToArray(_ref3, 2);\n\n        var note = _ref2[1];\n        var keyNumber = getTeoriaNote(note).key();\n\n        if (keyNumber < min || typeof min !== 'number') {\n          min = keyNumber;\n        }\n\n        if (keyNumber > max || typeof max !== 'number') {\n          max = keyNumber;\n        }\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return != null) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    return {\n      min: min - 1,\n      max: max\n    };\n  }\n\n  function drawPianoKey(key, active) {\n    return (key.graphic || new pixi.Graphics()).clear().beginFill(active ? key.activeColor : key.color).lineStyle(key.color === colors.whiteKey ? noteHeight / 10 : 0, colors.blackKey).drawRect(0, key.y, key.width, key.height).endFill();\n  }\n\n  function drawPianoKeys() {\n    var whiteKeys = [],\n        blackKeys = [],\n        blackKeyWidth = opt.pianoKeyWidth / 1.575;\n    keys = {};\n    activeKeys = new Set();\n    stage.removeChild(pianoContainer);\n    pianoContainer = new pixi.Container();\n\n    for (var i = noteRange.min; i < noteRange.max + 2; i++) {\n      var y = opt.height + (noteRange.min - i) * noteHeight,\n          note = teoria.note.fromKey(i),\n          chroma = note.chroma(),\n          key = {\n        keyNumber: note.key(),\n        activeColor: typeof opt.noteColor === 'number' ? opt.noteColor : opt.noteColor[chroma]\n      };\n\n      if (new Set([0, 2, 4, 5, 7, 9, 11]).has(chroma)) {\n        whiteKeys.push(Object.assign(key, {\n          y: y + (new Set([4, 11]).has(chroma) ? 0 : -noteHeight / 2),\n          width: opt.pianoKeyWidth,\n          height: new Set([2, 7, 9]).has(chroma) ? noteHeight * 2 : noteHeight * 1.5,\n          color: colors.whiteKey\n        }));\n      } else {\n        blackKeys.push(Object.assign(key, {\n          y: y,\n          width: blackKeyWidth,\n          height: noteHeight,\n          color: colors.blackKey\n        }));\n      }\n    }\n\n    whiteKeys.concat(blackKeys).forEach(function (key) {\n      var pixiKey = drawPianoKey(key);\n      keys[key.keyNumber] = Object.assign(key, {\n        graphic: pixiKey\n      });\n      pianoContainer.addChild(pixiKey);\n    });\n    stage.addChild(pianoContainer);\n  }\n\n  function transportTimeToX(transportTime, isNote) {\n    if (!transportTime) {\n      return 0;\n    }\n\n    var _transportTime$split = transportTime.split(':'),\n        _transportTime$split2 = _slicedToArray(_transportTime$split, 3),\n        bar = _transportTime$split2[0],\n        _transportTime$split3 = _transportTime$split2[1],\n        quarter = _transportTime$split3 === void 0 ? 0 : _transportTime$split3,\n        _transportTime$split4 = _transportTime$split2[2],\n        sixteenth = _transportTime$split4 === void 0 ? 0 : _transportTime$split4,\n        x = barWidth * bar + beatWidth * quarter + sixteenthWidth * sixteenth;\n\n    return isNote ? x : opt.pianoKeyWidth - x;\n  }\n\n  function drawNotes() {\n    var oldContainer = rollContainer.removeChild(noteContainer);\n    noteContainer = new pixi.Container();\n    var _iteratorNormalCompletion2 = true;\n    var _didIteratorError2 = false;\n    var _iteratorError2 = undefined;\n\n    try {\n      for (var _iterator2 = opt.noteData[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n        var _ref6 = _step2.value;\n\n        var _ref5 = _slicedToArray(_ref6, 3);\n\n        var transportTime = _ref5[0];\n        var note = _ref5[1];\n        var duration = _ref5[2];\n        var pixiNote = new pixi.Graphics(),\n            teoriaNote = getTeoriaNote(note),\n            keyNumber = teoriaNote.key(),\n            color = typeof opt.noteColor === 'number' ? opt.noteColor : opt.noteColor[teoriaNote.chroma()];\n        pixiNote.beginFill(color).drawRect(0, 0, barWidth / parseInt(duration), innerNoteHeight).endFill();\n        pixiNote.x = transportTimeToX(transportTime, true) + halfGridLineWidth;\n        pixiNote.y = opt.height - (keyNumber - noteRange.min) * noteHeight + halfGridLineWidth;\n        pixiNote.keyNumber = keyNumber;\n        noteContainer.addChild(pixiNote);\n      }\n    } catch (err) {\n      _didIteratorError2 = true;\n      _iteratorError2 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n          _iterator2.return();\n        }\n      } finally {\n        if (_didIteratorError2) {\n          throw _iteratorError2;\n        }\n      }\n    }\n\n    noteContainer.x = oldContainer ? oldContainer.x : transportTimeToX(opt.time);\n    rollContainer.addChild(noteContainer);\n  }\n\n  function moveVerticalGridLines(horizontalMovement) {\n    var verticalGridlines = gridlineContainers.vertical.children;\n    var _iteratorNormalCompletion3 = true;\n    var _didIteratorError3 = false;\n    var _iteratorError3 = undefined;\n\n    try {\n      for (var _iterator3 = verticalGridlines[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n        var _line = _step3.value;\n        _line.x -= horizontalMovement;\n      }\n    } catch (err) {\n      _didIteratorError3 = true;\n      _iteratorError3 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion3 && _iterator3.return != null) {\n          _iterator3.return();\n        }\n      } finally {\n        if (_didIteratorError3) {\n          throw _iteratorError3;\n        }\n      }\n    }\n\n    if (verticalGridlines[0].x + gridLineWidth < opt.pianoKeyWidth) {\n      var line = gridlineContainers.vertical.removeChildAt(0);\n      line.x = verticalGridlines[verticalGridlines.length - 1].x + gridLineSpacing;\n      gridlineContainers.vertical.addChild(line);\n    }\n  }\n\n  function getFirstVerticalGridLineX(transportX) {\n    var x = transportX;\n\n    while (x + gridLineSpacing < opt.pianoKeyWidth) {\n      x += gridLineSpacing;\n    }\n\n    return x;\n  }\n\n  function drawGridlines(type) {\n    var i;\n\n    if (!type || type === 'horizontal') {\n      gridlineContainers.main.removeChild(gridlineContainers.horizontal);\n      gridlineContainers.horizontal = new pixi.Container();\n\n      for (i = 0; i < noteRangeDiff + 1; i++) {\n        gridlineContainers.horizontal.addChild(new pixi.Graphics().beginFill(opt.gridLineColor).drawRect(0, i * noteHeight - halfGridLineWidth, opt.width, gridLineWidth).endFill());\n        var noteChroma = teoria.note.fromKey(i + 3).chroma();\n\n        if (new Set([0, 2, 4, 5, 7, 9, 11]).has(noteChroma)) {\n          gridlineContainers.horizontal.addChild(new pixi.Graphics().beginFill(opt.whiteGridBgColor).drawRect(0, i * noteHeight + halfGridLineWidth, opt.width, noteHeight - gridLineWidth).endFill());\n        }\n      }\n\n      gridlineContainers.main.addChild(gridlineContainers.horizontal);\n    }\n\n    if (!type || type === 'vertical') {\n      var offset = getFirstVerticalGridLineX(noteContainer ? noteContainer.x : transportTimeToX(opt.time));\n      gridlineContainers.main.removeChild(gridlineContainers.vertical);\n      gridlineContainers.vertical = new pixi.Container();\n\n      for (i = 0; i < opt.zoom * opt.resolution + 1; i++) {\n        var line = new pixi.Graphics().beginFill(opt.gridLineColor).drawRect(0, 0, gridLineWidth, opt.height).endFill();\n        line.x = offset + i * gridLineSpacing - halfGridLineWidth;\n        gridlineContainers.vertical.addChild(line);\n      }\n\n      gridlineContainers.main.addChild(gridlineContainers.vertical);\n    }\n\n    rollContainer.addChild(gridlineContainers.main);\n  }\n\n  function activateKeys() {\n    if (!opt.activateKeys) {\n      return;\n    }\n\n    var intersectedKeys = new Set();\n    var _iteratorNormalCompletion4 = true;\n    var _didIteratorError4 = false;\n    var _iteratorError4 = undefined;\n\n    try {\n      for (var _iterator4 = noteContainer.children[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n        var note = _step4.value;\n\n        if (note.containsPoint(new pixi.Point(opt.pianoKeyWidth, note.y))) {\n          intersectedKeys.add(note.keyNumber);\n        }\n      }\n    } catch (err) {\n      _didIteratorError4 = true;\n      _iteratorError4 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion4 && _iterator4.return != null) {\n          _iterator4.return();\n        }\n      } finally {\n        if (_didIteratorError4) {\n          throw _iteratorError4;\n        }\n      }\n    }\n\n    var _iteratorNormalCompletion5 = true;\n    var _didIteratorError5 = false;\n    var _iteratorError5 = undefined;\n\n    try {\n      for (var _iterator5 = intersectedKeys[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n        var intersectedKey = _step5.value;\n\n        if (!activeKeys.has(intersectedKey)) {\n          var key = keys[intersectedKey];\n          drawPianoKey(key, true);\n          activeKeys.add(intersectedKey);\n        }\n      }\n    } catch (err) {\n      _didIteratorError5 = true;\n      _iteratorError5 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion5 && _iterator5.return != null) {\n          _iterator5.return();\n        }\n      } finally {\n        if (_didIteratorError5) {\n          throw _iteratorError5;\n        }\n      }\n    }\n\n    var _iteratorNormalCompletion6 = true;\n    var _didIteratorError6 = false;\n    var _iteratorError6 = undefined;\n\n    try {\n      for (var _iterator6 = activeKeys[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {\n        var activeKey = _step6.value;\n\n        if (!intersectedKeys.has(activeKey)) {\n          var _key = keys[activeKey];\n          drawPianoKey(_key);\n          activeKeys.delete(activeKey);\n        }\n      }\n    } catch (err) {\n      _didIteratorError6 = true;\n      _iteratorError6 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion6 && _iterator6.return != null) {\n          _iterator6.return();\n        }\n      } finally {\n        if (_didIteratorError6) {\n          throw _iteratorError6;\n        }\n      }\n    }\n  }\n\n  function animate(frameTime) {\n    if (!lastTime) {\n      lastTime = frameTime;\n    }\n\n    var timeDiff = frameTime - lastTime,\n        horizontalMovement = timeDiff * pxMovementPerMs;\n    noteContainer.x = noteContainer.x - horizontalMovement;\n    moveVerticalGridLines(horizontalMovement);\n    activateKeys();\n    lastTime = frameTime;\n    renderer.render(stage);\n    playing ? requestAnimationFrame(animate) : lastTime = null;\n  }\n\n  function calculate() {\n    noteRange = getNoteRange(opt.noteData);\n    noteRangeDiff = noteRange.max - noteRange.min;\n    barWidth = (opt.width - opt.pianoKeyWidth) / opt.zoom;\n    beatWidth = (opt.width - opt.pianoKeyWidth) / (opt.zoom * 4);\n    sixteenthWidth = beatWidth / 4;\n    gridLineWidth = barWidth / 100;\n    halfGridLineWidth = gridLineWidth / 2;\n    gridLineSpacing = barWidth / opt.resolution;\n    beatsPerMs = opt.bpm / 60 / 1000;\n    pxMovementPerMs = beatWidth * beatsPerMs;\n    noteHeight = opt.height / noteRangeDiff;\n    innerNoteHeight = noteHeight - gridLineWidth;\n  }\n\n  (function init() {\n    stage.addChild(rollContainer);\n    calculate();\n    drawGridlines();\n    drawNotes();\n    drawPianoKeys();\n    renderer.backgroundColor = opt.blackGridBgColor;\n    renderer.render(stage);\n  })();\n  /**\n   * The piano roll API\n   * @typedef pianoRollAPI\n   * @type {Object}\n   * @global\n   */\n\n\n  var pianoRollAPI = {\n    /**\n     * Contains methods that control playback\n     * @memberof pianoRollAPI\n     * @type {Object}\n     */\n    playback: {\n      /**\n       * Pause if playing or play if paused\n       * @param {transportTime} [time] - If paused, the position to begin playing. If omitted, playback will begin at the current position.\n       */\n      toggle: function toggle(time) {\n        playing ? pianoRollAPI.playback.pause() : pianoRollAPI.playback.play(time);\n      },\n\n      /**\n       * Begin playback\n       * @param {transportTime} [time] - The position to begin playing. If omitted, playback will begin at the current position.\n       */\n      play: function play(time) {\n        if (!playing) {\n          if (time) {\n            pianoRollAPI.playback.seek(time);\n          }\n\n          playing = true;\n          requestAnimationFrame(animate);\n        }\n      },\n\n      /**\n       * Pause playback\n       */\n      pause: function pause() {\n        playing = false;\n      },\n\n      /**\n       * Change the playback position\n       * @param {transportTime} time - The new playback position\n       */\n      seek: function seek(time) {\n        opt.time = time;\n        noteContainer.x = transportTimeToX(time);\n        drawGridlines('vertical');\n        rollContainer.addChild(rollContainer.removeChild(noteContainer));\n        renderer.render(stage);\n      }\n    },\n\n    /**\n     * Change the bpm by changing this property\n     * @memberof pianoRollAPI\n     * @type {number}\n     */\n    set bpm(bpm) {\n      opt.bpm = bpm;\n      calculate();\n    },\n\n    /**\n     * Change the zoom by changing this property\n     * @memberof pianoRollAPI\n     * @type {number}\n     */\n    set zoom(zoom) {\n      opt.zoom = zoom;\n      calculate();\n      drawGridlines();\n      drawNotes();\n      renderer.render(stage);\n    },\n\n    /**\n     * Change the resolution by changing this property\n     * @memberof pianoRollAPI\n     * @type {number}\n     */\n    set resolution(resolution) {\n      opt.resolution = resolution;\n      calculate();\n      drawGridlines('vertical');\n      rollContainer.addChild(rollContainer.removeChild(noteContainer));\n      renderer.render(stage);\n    },\n\n    /**\n     * Change the note data by changing this property\n     * @memberof pianoRollAPI\n     * @type {noteData}\n     */\n    set noteData(noteData) {\n      opt.noteData = noteData;\n      calculate();\n      drawGridlines('horizontal');\n      drawNotes();\n      drawPianoKeys();\n      renderer.render(stage);\n    },\n\n    /**\n     * Whether or not playback is ongoing\n     * @memberof pianoRollAPI\n     * @type {boolean}\n     * @readonly\n     */\n    get playing() {\n      return playing;\n    },\n\n    /**\n     * The piano roll canvas element\n     * @memberof pianoRollAPI\n     * @type {HTMLElement}\n     * @readonly\n     */\n    get view() {\n      return renderer.view;\n    }\n\n  };\n  return pianoRollAPI;\n}\n\nexport default pixiPianoRoll;"],"mappings":"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"},"metadata":{},"sourceType":"module"}